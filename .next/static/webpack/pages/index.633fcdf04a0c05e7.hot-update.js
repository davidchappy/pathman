"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./pathman/game.ts":
/*!*************************!*\
  !*** ./pathman/game.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./pathman/types.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./pathman/config.ts\");\n/* harmony import */ var _maze__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maze */ \"./pathman/maze.ts\");\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state */ \"./pathman/state.ts\");\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw */ \"./pathman/draw.ts\");\n/* harmony import */ var _pathfinding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pathfinding */ \"./pathman/pathfinding.ts\");\n\n\n\n\n\n\nconst game = (canvas)=>{\n    let state = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getInitialState)();\n    const { draw, drawOverlay } = (0,_draw__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(canvas, state);\n    const init = ()=>{\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        calculateScale();\n    };\n    const calculateScale = ()=>{\n        // TODO: calculate width based on the number of cells in the maze\n        // const mazeWidth = 0 + config.sidebarWidth\n        const scale = window.innerWidth / window.innerWidth;\n        state.scale = scale;\n    };\n    const updatePathman = ()=>{\n        // First, find the cell that pathman is in currently\n        const cellX = Math.floor(state.pathman.x / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n        const cellY = Math.floor(state.pathman.y / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n        state.pathman.currentCell = {\n            x: cellX,\n            y: cellY\n        };\n        // Animate mouth\n        if (state.pathman.isMoving) {\n            const mouthSpeed = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.mouthSpeed // Speed of mouth opening/closing\n            ;\n            const maxLowestAngle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.maxLowestAngle // Maximum mouth angle in radians\n            ;\n            if (state.pathman.mouthOpening) {\n                state.pathman.mouthAngle -= mouthSpeed // Increase the mouth angle\n                ;\n                if (state.pathman.mouthAngle < maxLowestAngle) {\n                    state.pathman.mouthAngle = maxLowestAngle // Limit the mouth angle\n                    ;\n                    state.pathman.mouthOpening = false // Start closing the mouth\n                    ;\n                }\n            } else {\n                state.pathman.mouthAngle += mouthSpeed // Decrease the mouth angle\n                ;\n                if (state.pathman.mouthAngle > 0) {\n                    state.pathman.mouthAngle = 0;\n                    state.pathman.mouthOpening = true // Start opening the mouth\n                    ;\n                }\n            }\n        }\n        // Move\n        if (state.pathman.direction === \"none\" || !state.pathman.isMoving) return;\n        let newX = state.pathman.x;\n        let newY = state.pathman.y;\n        if (state.pathman.direction === \"right\") {\n            newX += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        if (state.pathman.direction === \"left\") {\n            newX -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        if (state.pathman.direction === \"up\") {\n            newY -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        if (state.pathman.direction === \"down\") {\n            newY += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        const pathmanRadius = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.size / 2;\n        // Check for collisions\n        const maze = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells;\n        const currentCell = {\n            x: cellX,\n            y: cellY\n        };\n        state.debug.currentPathmanPosition = {\n            x: state.pathman.x,\n            y: state.pathman.y,\n            currentCell\n        };\n        const direction = state.pathman.direction;\n        let adjacentCell;\n        let willColide = false;\n        if (direction === \"right\" && state.pathman.x >= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - pathmanRadius) {\n            var _maze_cellY;\n            adjacentCell = (_maze_cellY = maze[cellY]) === null || _maze_cellY === void 0 ? void 0 : _maze_cellY[cellX + 1];\n        }\n        if (direction === \"left\" && state.pathman.x <= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + pathmanRadius) {\n            var _maze_cellY1;\n            adjacentCell = (_maze_cellY1 = maze[cellY]) === null || _maze_cellY1 === void 0 ? void 0 : _maze_cellY1[cellX - 1];\n        }\n        if (direction === \"up\" && state.pathman.y <= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + pathmanRadius) {\n            var _maze_;\n            adjacentCell = (_maze_ = maze[cellY - 1]) === null || _maze_ === void 0 ? void 0 : _maze_[cellX];\n        }\n        if (direction === \"down\" && state.pathman.y >= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - pathmanRadius) {\n            var _maze_1;\n            adjacentCell = (_maze_1 = maze[cellY + 1]) === null || _maze_1 === void 0 ? void 0 : _maze_1[cellX];\n        }\n        // Check for collisions with walls\n        if (adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallHorizontal || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallVertical || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopLeft || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopRight || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomLeft || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomRight) {\n            willColide = true;\n        }\n        // Check for collisions with canvas\n        // if (newX - pathmanRadius < 0 || newX + pathmanRadius > canvas.width) {\n        //   willColide = true\n        // }\n        // if (newY - pathmanRadius < 0 || newY + pathmanRadius > canvas.height) {\n        //   willColide = true\n        // }\n        if (willColide) {\n            state.pathman.isMoving = false;\n            return;\n        }\n        // Allow wrapping around the maze\n        const { x: mazeWidth, y: mazeHeight } = (0,_maze__WEBPACK_IMPORTED_MODULE_2__.calculateMazeDimensions)();\n        // If going right, should wrap to the same x position on the left side of the maze\n        if (direction === \"right\" && newX + pathmanRadius > mazeWidth) {\n            newX = 0 + pathmanRadius;\n        }\n        // If going left, should wrap to the same x position on the right side of the maze\n        if (direction === \"left\" && newX - pathmanRadius < 0) {\n            newX = mazeWidth - pathmanRadius;\n        }\n        // If going up, should wrap to the same y position on the bottom side of the maze\n        if (direction === \"up\" && newY - pathmanRadius < 0) {\n            newY = mazeHeight - pathmanRadius;\n        }\n        // If going down, should wrap to the same y position on the top side of the maze\n        if (direction === \"down\" && newY + pathmanRadius > mazeHeight) {\n            newY = 0 + pathmanRadius;\n        }\n        state.pathman.x = newX;\n        state.pathman.y = newY;\n        state.pathman.currentCell = {\n            x: Math.floor(newX / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize),\n            y: Math.floor(newY / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize)\n        };\n    };\n    const updateGhosts = ()=>{\n        const ghosts = state.ghosts;\n        if (!state.pathman.currentCell) return;\n        ghosts.forEach((ghost, index)=>{\n            var _state_pathman_currentCell, _state_pathman_currentCell1, _ghost_path;\n            // First, find the cell that ghost is in currently\n            const cellX = Math.floor(ghost.x / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n            const cellY = Math.floor(ghost.y / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n            const currentCell = {\n                x: cellX,\n                y: cellY\n            };\n            ghost.currentCell = currentCell;\n            if (ghost.path.length === 0) {\n                ghost.path = (0,_pathfinding__WEBPACK_IMPORTED_MODULE_5__.aStar)({\n                    x: ghost.currentCell.x,\n                    y: ghost.currentCell.y\n                }, {\n                    x: state.pathman.currentCell.x || 1,\n                    y: state.pathman.currentCell.y || 1\n                }, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells);\n            }\n            // Move\n            const ghostRadius = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.size / 2;\n            const maze = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells;\n            let newX = ghost.x;\n            let newY = ghost.y;\n            // Advance towards the next step in the path\n            const calculateDirection = (entity, nextStep)=>{\n                // check for same cell\n                if (nextStep.x === entity.currentCell.x && nextStep.y === entity.currentCell.y) {\n                    return entity.direction;\n                }\n                // Calculate the center position of the next cell in absolute canvas coordinates\n                const nextCellCenterX = nextStep.x * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2;\n                const nextCellCenterY = nextStep.y * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2;\n                // Calculate the difference in cell coordinates between the entity's current cell and the next step\n                const cellDeltaX = nextStep.x - entity.currentCell.x;\n                const cellDeltaY = nextStep.y - entity.currentCell.y;\n                // Determine the primary axis of movement based on the larger delta\n                const primaryAxis = Math.abs(cellDeltaX) > Math.abs(cellDeltaY) ? \"x\" : \"y\";\n                // Initialize the direction as \"none\"\n                let direction = \"none\";\n                // Determine the direction based on the primary axis and the sign of the delta\n                if (primaryAxis === \"x\") {\n                    direction = cellDeltaX > 0 ? \"right\" : \"left\";\n                } else {\n                    direction = cellDeltaY > 0 ? \"down\" : \"up\";\n                }\n                if (entity.direction === \"none\") {\n                    return direction;\n                }\n                // Check if the entity has reached the center of the next cell along the primary axis of movement\n                // If not, continue in the current direction\n                if (entity.direction === \"right\" && entity.x < nextCellCenterX) return entity.direction;\n                if (entity.direction === \"left\" && entity.x > nextCellCenterX) return entity.direction;\n                if (entity.direction === \"up\" && entity.y > nextCellCenterY) return entity.direction;\n                if (entity.direction === \"down\" && entity.y < nextCellCenterY) return entity.direction;\n                // Return the new direction if the entity has reached the center of the next cell\n                return direction;\n            };\n            if (ghost.path.length > 0) {\n                if (ghost.path[0].x === ghost.currentCell.x && ghost.path[0].y === ghost.currentCell.y) {\n                    ghost.path.shift();\n                }\n                const nextStep = ghost.path[0]// Get the next step in the path\n                ;\n                // console.log(`ghost ${index} next step`, nextStep.x, nextStep.y, ghost.direction)\n                if (!nextStep) return;\n                ghost.direction = calculateDirection(ghost, nextStep) // Calculate the new direction based on the next step\n                ;\n            // console.log(`ghost ${index} new direction`, ghost.direction)\n            }\n            // Move\n            if (ghost.direction === \"right\") {\n                newX += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            if (ghost.direction === \"left\") {\n                newX -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            if (ghost.direction === \"up\") {\n                newY -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            if (ghost.direction === \"down\") {\n                newY += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            // Check for collisions\n            const direction = ghost.direction;\n            let adjacentCellType;\n            let adjacentCell;\n            let willColide = false;\n            if (direction === \"right\" && ghost.x >= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - ghostRadius) {\n                var _maze_cellY;\n                adjacentCellType = (_maze_cellY = maze[cellY]) === null || _maze_cellY === void 0 ? void 0 : _maze_cellY[cellX + 1];\n                adjacentCell = {\n                    x: cellX + 1,\n                    y: cellY\n                };\n            }\n            if (direction === \"left\" && ghost.x <= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + ghostRadius) {\n                var _maze_cellY1;\n                adjacentCellType = (_maze_cellY1 = maze[cellY]) === null || _maze_cellY1 === void 0 ? void 0 : _maze_cellY1[cellX - 1];\n                adjacentCell = {\n                    x: cellX - 1,\n                    y: cellY\n                };\n            }\n            if (direction === \"up\" && ghost.y <= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + ghostRadius) {\n                var _maze_;\n                adjacentCellType = (_maze_ = maze[cellY - 1]) === null || _maze_ === void 0 ? void 0 : _maze_[cellX];\n                adjacentCell = {\n                    x: cellX,\n                    y: cellY - 1\n                };\n            }\n            if (direction === \"down\" && ghost.y >= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - ghostRadius) {\n                var _maze_1;\n                adjacentCellType = (_maze_1 = maze[cellY + 1]) === null || _maze_1 === void 0 ? void 0 : _maze_1[cellX];\n                adjacentCell = {\n                    x: cellX,\n                    y: cellY + 1\n                };\n            }\n            // Check for collisions with walls\n            if (adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallHorizontal || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallVertical || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomLeft || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomRight || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopLeft || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopRight) {\n                console.log(\"ghost collided with wall\");\n                willColide = true;\n            }\n            if ((adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.x) === ((_state_pathman_currentCell = state.pathman.currentCell) === null || _state_pathman_currentCell === void 0 ? void 0 : _state_pathman_currentCell.x) && (adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.y) === ((_state_pathman_currentCell1 = state.pathman.currentCell) === null || _state_pathman_currentCell1 === void 0 ? void 0 : _state_pathman_currentCell1.y)) {\n                console.log(\"ghost collided with pathman\");\n                willColide = true;\n                state.phase = \"game-over\";\n            }\n            const otherGhosts = ghosts.filter((g)=>g.id !== ghost.id);\n            otherGhosts.forEach((otherGhost)=>{\n                if ((adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.x) === otherGhost.currentCell.x && (adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.y) === otherGhost.currentCell.y) {\n                    console.log(\"ghost collided with another ghost\");\n                    willColide = true;\n                }\n            });\n            if (willColide) {\n                ghost.isMoving = false;\n                return;\n            }\n            // Allow wrapping around the maze\n            const { x: mazeWidth, y: mazeHeight } = (0,_maze__WEBPACK_IMPORTED_MODULE_2__.calculateMazeDimensions)();\n            // If going right, should wrap to the same x position on the left side of the maze\n            if (direction === \"right\" && newX + ghostRadius > mazeWidth) {\n                newX = 0 + ghostRadius;\n            }\n            // If going left, should wrap to the same x position on the right side of the maze\n            if (direction === \"left\" && newX - ghostRadius < 0) {\n                newX = mazeWidth - ghostRadius;\n            }\n            // If going up, should wrap to the same y position on the bottom side of the maze\n            if (direction === \"up\" && newY - ghostRadius < 0) {\n                newY = mazeHeight - ghostRadius;\n            }\n            // If going down, should wrap to the same y position on the top side of the maze\n            if (direction === \"down\" && newY + ghostRadius > mazeHeight) {\n                newY = 0 + ghostRadius;\n            }\n            ghost.x = newX;\n            ghost.y = newY;\n            ghost.currentCell = {\n                x: Math.floor(newX / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize),\n                y: Math.floor(newY / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize)\n            };\n            if (ghost.currentCell.x !== currentCell.x || ghost.currentCell.y !== currentCell.y) {\n                var _state_pathman_currentCell2, _state_pathman_currentCell3;\n                ghost.path = (0,_pathfinding__WEBPACK_IMPORTED_MODULE_5__.aStar)({\n                    x: ghost.currentCell.x,\n                    y: ghost.currentCell.y\n                }, {\n                    x: ((_state_pathman_currentCell2 = state.pathman.currentCell) === null || _state_pathman_currentCell2 === void 0 ? void 0 : _state_pathman_currentCell2.x) || 1,\n                    y: ((_state_pathman_currentCell3 = state.pathman.currentCell) === null || _state_pathman_currentCell3 === void 0 ? void 0 : _state_pathman_currentCell3.y) || 1\n                }, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells);\n            // console.log(`ghost ${index} reset path`, ghost.path[0])\n            }\n            // Periodically or when Pathman moves, update the ghost's path\n            // if (shouldUpdatePath(ghost)) {\n            // const paths = getTopPaths(ghost, state.pathman, config.maze.cells, 3); // Get top 3 paths\n            // const chosenPath = paths[Math.floor(Math.random() * paths.length)]; // Randomly choose one\n            // ghost.path = chosenPath;\n            // Set the next direction based on the path\n            if (((_ghost_path = ghost.path) === null || _ghost_path === void 0 ? void 0 : _ghost_path.length) > 0) {\n            // const nextStep = ghost.path.shift() // Get the next step in the path\n            // ghost.direction = calculateDirection(ghost, nextStep) // Calculate the new direction based on the next step\n            }\n        });\n    };\n    const updatePellets = ()=>{\n        // Check for collisions\n        const pathmanRadius = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.size / 2;\n        for(let i = 0; i < state.pellets.length; i++){\n            const pellet = state.pellets[i];\n            const distance = Math.sqrt(Math.pow(state.pathman.x - pellet.x, 2) + Math.pow(state.pathman.y - pellet.y, 2));\n            if (distance < pathmanRadius + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pellets.size) {\n                state.pellets.splice(i, 1);\n                i--;\n            }\n        }\n        for(let i = 0; i < state.powerPellets.length; i++){\n            const pellet = state.powerPellets[i];\n            const distance = Math.sqrt(Math.pow(state.pathman.x - pellet.x, 2) + Math.pow(state.pathman.y - pellet.y, 2));\n            if (distance < pathmanRadius + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].powerPellets.size) {\n                state.powerPellets.splice(i, 1);\n                i--;\n            }\n        }\n    };\n    const updateStats = (deltaTime)=>{\n        state.currentFPS = 1000 / deltaTime;\n    };\n    const handleResize = (event)=>{\n        // Resize the canvas\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        calculateScale();\n        draw();\n    };\n    const handleKeyUp = (event)=>{\n        if (state.phase === \"game-over\" || state.phase === \"game-won\") return;\n        // Toggle pause\n        if (event.key === \" \") {\n            state.phase = state.phase === \"paused\" ? \"playing\" : \"paused\";\n            if (state.phase === \"paused\") {\n                state.overlayText = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].overlayMessages.paused;\n                drawOverlay();\n            } else {\n                state.overlayText = \"\";\n                // If unpausing, re-start the animation loop\n                requestAnimationFrame(animate);\n            }\n        }\n        if (state.phase === \"paused\") return;\n        if (event.key === \"ArrowRight\" || event.key === \"d\") {\n            state.pathman.direction = \"right\";\n            state.pathman.isMoving = true;\n        }\n        if (event.key === \"ArrowLeft\" || event.key === \"a\") {\n            state.pathman.direction = \"left\";\n            state.pathman.isMoving = true;\n        }\n        if (event.key === \"ArrowUp\" || event.key === \"w\") {\n            state.pathman.direction = \"up\";\n            state.pathman.isMoving = true;\n        }\n        if (event.key === \"ArrowDown\" || event.key === \"s\") {\n            state.pathman.direction = \"down\";\n            state.pathman.isMoving = true;\n        }\n    };\n    const handleClick = (event)=>{\n        const clickLocation = {\n            x: event.clientX,\n            y: event.clientY\n        };\n        setTimeout(()=>{\n            state.debug.clickLocation = null;\n        }, 4000);\n        state.debug.clickLocation = clickLocation;\n        const resetButton = {\n            x: canvas.width - 120,\n            y: 86,\n            width: 100,\n            height: 30\n        };\n        if (event.clientX >= resetButton.x && event.clientX <= resetButton.x + resetButton.width && event.clientY >= resetButton.y && event.clientY <= resetButton.y + resetButton.height) {\n            reset();\n        }\n    };\n    const attachEvents = ()=>{\n        window.addEventListener(\"resize\", handleResize);\n        window.addEventListener(\"keyup\", handleKeyUp);\n        window.addEventListener(\"click\", handleClick);\n    };\n    const detachEvents = ()=>{\n        window.removeEventListener(\"resize\", handleResize);\n        window.removeEventListener(\"keyup\", handleKeyUp);\n        window.removeEventListener(\"click\", handleClick);\n    };\n    const animate = (timestamp)=>{\n        // Initialize the previous timestamp\n        if (state.previousAnimationTimestamp === undefined) {\n            state.previousAnimationTimestamp = timestamp;\n            requestAnimationFrame(animate);\n            return;\n        }\n        const deltaTime = timestamp - state.previousAnimationTimestamp;\n        // Update stuff\n        if (state.phase === \"playing\") {\n            updatePathman();\n            updateGhosts();\n            updatePellets();\n            updateStats(deltaTime);\n        }\n        // Draw stuff\n        draw();\n        state.previousAnimationTimestamp = timestamp;\n        if (state.phase === \"paused\") return;\n        requestAnimationFrame(animate);\n    };\n    const run = ()=>{\n        console.log(\"Starting Pathman game...\", canvas);\n        init();\n        attachEvents();\n        draw();\n        // fire a resize event\n        const resizeEvent = new Event(\"resize\");\n        window.dispatchEvent(resizeEvent);\n        // Start the animation loop\n        requestAnimationFrame(animate);\n    };\n    const quit = ()=>{\n        console.log(\"Stopping Pathman game...\");\n        state.previousAnimationTimestamp = undefined;\n        detachEvents();\n    };\n    const reset = ()=>{\n        console.log(\"Resetting Pathman game...\");\n        quit();\n        state = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getInitialState)();\n        run();\n    };\n    return {\n        run,\n        quit,\n        reset\n    };\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (game);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFVBQVU7UUFFOUJ5QixzQkFBc0JDO0lBQ3hCO0lBRUEsTUFBTWUsTUFBTTtRQUNWM0MsUUFBUUMsR0FBRyxDQUFDLDRCQUE0Qm5FO1FBRXhDSTtRQUNBa0c7UUFDQXBHO1FBRUEsc0JBQXNCO1FBQ3RCLE1BQU00RyxjQUFjLElBQUlDLE1BQU07UUFDOUJ6RyxPQUFPMEcsYUFBYSxDQUFDRjtRQUVyQiwyQkFBMkI7UUFDM0JqQixzQkFBc0JDO0lBQ3hCO0lBRUEsTUFBTW1CLE9BQU87UUFDWC9DLFFBQVFDLEdBQUcsQ0FBQztRQUVabEUsTUFBTTBHLDBCQUEwQixHQUFHQztRQUNuQ0o7SUFDRjtJQUVBLE1BQU1ILFFBQVE7UUFDWm5DLFFBQVFDLEdBQUcsQ0FBQztRQUNaOEM7UUFDQWhILFFBQVFOLHVEQUFlQTtRQUN2QmtIO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xBO1FBQ0FJO1FBQ0FaO0lBQ0Y7QUFDRjtBQUVBLCtEQUFldEcsSUFBSUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYXRobWFuL2dhbWUudHM/ZWU1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEdhbWVTdGF0ZSwgRGlyZWN0aW9uIH0gZnJvbSBcIi4vdHlwZXNcIlxuaW1wb3J0IHsgQ2VsbFR5cGUsIEVudGl0eSwgUGF0aE5vZGUsIE5vZGUgfSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgY29uZmlnIGZyb20gXCIuL2NvbmZpZ1wiXG5pbXBvcnQgeyBjYWxjdWxhdGVNYXplRGltZW5zaW9ucyB9IGZyb20gXCIuL21hemVcIlxuaW1wb3J0IHsgZ2V0SW5pdGlhbFN0YXRlIH0gZnJvbSBcIi4vc3RhdGVcIlxuaW1wb3J0IHVzZURyYXcgZnJvbSBcIi4vZHJhd1wiXG5pbXBvcnQgeyBhU3RhciBhcyBmaW5kUGF0aCB9IGZyb20gXCIuL3BhdGhmaW5kaW5nXCJcblxuY29uc3QgZ2FtZSA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XG4gIGxldCBzdGF0ZTogR2FtZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKClcbiAgY29uc3QgeyBkcmF3LCBkcmF3T3ZlcmxheSB9ID0gdXNlRHJhdyhjYW52YXMsIHN0YXRlKVxuXG4gIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG5cbiAgICBjYWxjdWxhdGVTY2FsZSgpXG4gIH1cblxuICBjb25zdCBjYWxjdWxhdGVTY2FsZSA9ICgpID0+IHtcbiAgICAvLyBUT0RPOiBjYWxjdWxhdGUgd2lkdGggYmFzZWQgb24gdGhlIG51bWJlciBvZiBjZWxscyBpbiB0aGUgbWF6ZVxuICAgIC8vIGNvbnN0IG1hemVXaWR0aCA9IDAgKyBjb25maWcuc2lkZWJhcldpZHRoXG4gICAgY29uc3Qgc2NhbGUgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgc3RhdGUuc2NhbGUgPSBzY2FsZVxuICB9XG5cbiAgY29uc3QgdXBkYXRlUGF0aG1hbiA9ICgpID0+IHtcbiAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2VsbCB0aGF0IHBhdGhtYW4gaXMgaW4gY3VycmVudGx5XG4gICAgY29uc3QgY2VsbFggPSBNYXRoLmZsb29yKHN0YXRlLnBhdGhtYW4ueCAvIGNvbmZpZy5jZWxsU2l6ZSlcbiAgICBjb25zdCBjZWxsWSA9IE1hdGguZmxvb3Ioc3RhdGUucGF0aG1hbi55IC8gY29uZmlnLmNlbGxTaXplKVxuICAgIHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGwgPSB7IHg6IGNlbGxYLCB5OiBjZWxsWSB9XG5cbiAgICAvLyBBbmltYXRlIG1vdXRoXG4gICAgaWYgKHN0YXRlLnBhdGhtYW4uaXNNb3ZpbmcpIHtcbiAgICAgIGNvbnN0IG1vdXRoU3BlZWQgPSBjb25maWcucGF0aG1hbi5tb3V0aFNwZWVkIC8vIFNwZWVkIG9mIG1vdXRoIG9wZW5pbmcvY2xvc2luZ1xuICAgICAgY29uc3QgbWF4TG93ZXN0QW5nbGUgPSBjb25maWcucGF0aG1hbi5tYXhMb3dlc3RBbmdsZSAvLyBNYXhpbXVtIG1vdXRoIGFuZ2xlIGluIHJhZGlhbnNcblxuICAgICAgaWYgKHN0YXRlLnBhdGhtYW4ubW91dGhPcGVuaW5nKSB7XG4gICAgICAgIHN0YXRlLnBhdGhtYW4ubW91dGhBbmdsZSAtPSBtb3V0aFNwZWVkIC8vIEluY3JlYXNlIHRoZSBtb3V0aCBhbmdsZVxuICAgICAgICBpZiAoc3RhdGUucGF0aG1hbi5tb3V0aEFuZ2xlIDwgbWF4TG93ZXN0QW5nbGUpIHtcbiAgICAgICAgICBzdGF0ZS5wYXRobWFuLm1vdXRoQW5nbGUgPSBtYXhMb3dlc3RBbmdsZSAvLyBMaW1pdCB0aGUgbW91dGggYW5nbGVcbiAgICAgICAgICBzdGF0ZS5wYXRobWFuLm1vdXRoT3BlbmluZyA9IGZhbHNlIC8vIFN0YXJ0IGNsb3NpbmcgdGhlIG1vdXRoXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBhdGhtYW4ubW91dGhBbmdsZSArPSBtb3V0aFNwZWVkIC8vIERlY3JlYXNlIHRoZSBtb3V0aCBhbmdsZVxuICAgICAgICBpZiAoc3RhdGUucGF0aG1hbi5tb3V0aEFuZ2xlID4gMCkge1xuICAgICAgICAgIHN0YXRlLnBhdGhtYW4ubW91dGhBbmdsZSA9IDBcbiAgICAgICAgICBzdGF0ZS5wYXRobWFuLm1vdXRoT3BlbmluZyA9IHRydWUgLy8gU3RhcnQgb3BlbmluZyB0aGUgbW91dGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1vdmVcbiAgICBpZiAoc3RhdGUucGF0aG1hbi5kaXJlY3Rpb24gPT09IFwibm9uZVwiIHx8ICFzdGF0ZS5wYXRobWFuLmlzTW92aW5nKSByZXR1cm5cblxuICAgIGxldCBuZXdYID0gc3RhdGUucGF0aG1hbi54XG4gICAgbGV0IG5ld1kgPSBzdGF0ZS5wYXRobWFuLnlcblxuICAgIGlmIChzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICBuZXdYICs9IGNvbmZpZy5wYXRobWFuLnNwZWVkXG4gICAgfVxuICAgIGlmIChzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIG5ld1ggLT0gY29uZmlnLnBhdGhtYW4uc3BlZWRcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uID09PSBcInVwXCIpIHtcbiAgICAgIG5ld1kgLT0gY29uZmlnLnBhdGhtYW4uc3BlZWRcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uID09PSBcImRvd25cIikge1xuICAgICAgbmV3WSArPSBjb25maWcucGF0aG1hbi5zcGVlZFxuICAgIH1cblxuICAgIGNvbnN0IHBhdGhtYW5SYWRpdXMgPSBjb25maWcucGF0aG1hbi5zaXplIC8gMlxuXG4gICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcbiAgICBjb25zdCBtYXplID0gY29uZmlnLm1hemUuY2VsbHNcbiAgICBjb25zdCBjdXJyZW50Q2VsbCA9IHsgeDogY2VsbFgsIHk6IGNlbGxZIH1cbiAgICBzdGF0ZS5kZWJ1Zy5jdXJyZW50UGF0aG1hblBvc2l0aW9uID0ge1xuICAgICAgeDogc3RhdGUucGF0aG1hbi54LFxuICAgICAgeTogc3RhdGUucGF0aG1hbi55LFxuICAgICAgY3VycmVudENlbGwsXG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gc3RhdGUucGF0aG1hbi5kaXJlY3Rpb25cbiAgICBsZXQgYWRqYWNlbnRDZWxsXG5cbiAgICBsZXQgd2lsbENvbGlkZSA9IGZhbHNlXG5cbiAgICBpZiAoXG4gICAgICBkaXJlY3Rpb24gPT09IFwicmlnaHRcIiAmJlxuICAgICAgc3RhdGUucGF0aG1hbi54ID49XG4gICAgICAgIGNlbGxYICogY29uZmlnLmNlbGxTaXplICsgY29uZmlnLmNlbGxTaXplIC0gcGF0aG1hblJhZGl1c1xuICAgICkge1xuICAgICAgYWRqYWNlbnRDZWxsID0gbWF6ZVtjZWxsWV0/LltjZWxsWCArIDFdXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZGlyZWN0aW9uID09PSBcImxlZnRcIiAmJlxuICAgICAgc3RhdGUucGF0aG1hbi54IDw9IGNlbGxYICogY29uZmlnLmNlbGxTaXplICsgcGF0aG1hblJhZGl1c1xuICAgICkge1xuICAgICAgYWRqYWNlbnRDZWxsID0gbWF6ZVtjZWxsWV0/LltjZWxsWCAtIDFdXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZGlyZWN0aW9uID09PSBcInVwXCIgJiZcbiAgICAgIHN0YXRlLnBhdGhtYW4ueSA8PSBjZWxsWSAqIGNvbmZpZy5jZWxsU2l6ZSArIHBhdGhtYW5SYWRpdXNcbiAgICApIHtcbiAgICAgIGFkamFjZW50Q2VsbCA9IG1hemVbY2VsbFkgLSAxXT8uW2NlbGxYXVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgJiZcbiAgICAgIHN0YXRlLnBhdGhtYW4ueSA+PVxuICAgICAgICBjZWxsWSAqIGNvbmZpZy5jZWxsU2l6ZSArIGNvbmZpZy5jZWxsU2l6ZSAtIHBhdGhtYW5SYWRpdXNcbiAgICApIHtcbiAgICAgIGFkamFjZW50Q2VsbCA9IG1hemVbY2VsbFkgKyAxXT8uW2NlbGxYXVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zIHdpdGggd2FsbHNcbiAgICBpZiAoXG4gICAgICBhZGphY2VudENlbGwgPT09IENlbGxUeXBlLldhbGxIb3Jpem9udGFsIHx8XG4gICAgICBhZGphY2VudENlbGwgPT09IENlbGxUeXBlLldhbGxWZXJ0aWNhbCB8fFxuICAgICAgYWRqYWNlbnRDZWxsID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyVG9wTGVmdCB8fFxuICAgICAgYWRqYWNlbnRDZWxsID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyVG9wUmlnaHQgfHxcbiAgICAgIGFkamFjZW50Q2VsbCA9PT0gQ2VsbFR5cGUuV2FsbENvcm5lckJvdHRvbUxlZnQgfHxcbiAgICAgIGFkamFjZW50Q2VsbCA9PT0gQ2VsbFR5cGUuV2FsbENvcm5lckJvdHRvbVJpZ2h0XG4gICAgKSB7XG4gICAgICB3aWxsQ29saWRlID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zIHdpdGggY2FudmFzXG4gICAgLy8gaWYgKG5ld1ggLSBwYXRobWFuUmFkaXVzIDwgMCB8fCBuZXdYICsgcGF0aG1hblJhZGl1cyA+IGNhbnZhcy53aWR0aCkge1xuICAgIC8vICAgd2lsbENvbGlkZSA9IHRydWVcbiAgICAvLyB9XG5cbiAgICAvLyBpZiAobmV3WSAtIHBhdGhtYW5SYWRpdXMgPCAwIHx8IG5ld1kgKyBwYXRobWFuUmFkaXVzID4gY2FudmFzLmhlaWdodCkge1xuICAgIC8vICAgd2lsbENvbGlkZSA9IHRydWVcbiAgICAvLyB9XG5cbiAgICBpZiAod2lsbENvbGlkZSkge1xuICAgICAgc3RhdGUucGF0aG1hbi5pc01vdmluZyA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBBbGxvdyB3cmFwcGluZyBhcm91bmQgdGhlIG1hemVcbiAgICBjb25zdCB7IHg6IG1hemVXaWR0aCwgeTogbWF6ZUhlaWdodCB9ID0gY2FsY3VsYXRlTWF6ZURpbWVuc2lvbnMoKVxuXG4gICAgLy8gSWYgZ29pbmcgcmlnaHQsIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHggcG9zaXRpb24gb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgbWF6ZVxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIiAmJiBuZXdYICsgcGF0aG1hblJhZGl1cyA+IG1hemVXaWR0aCkge1xuICAgICAgbmV3WCA9IDAgKyBwYXRobWFuUmFkaXVzXG4gICAgfVxuXG4gICAgLy8gSWYgZ29pbmcgbGVmdCwgc2hvdWxkIHdyYXAgdG8gdGhlIHNhbWUgeCBwb3NpdGlvbiBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbWF6ZVxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwibGVmdFwiICYmIG5ld1ggLSBwYXRobWFuUmFkaXVzIDwgMCkge1xuICAgICAgbmV3WCA9IG1hemVXaWR0aCAtIHBhdGhtYW5SYWRpdXNcbiAgICB9XG5cbiAgICAvLyBJZiBnb2luZyB1cCwgc2hvdWxkIHdyYXAgdG8gdGhlIHNhbWUgeSBwb3NpdGlvbiBvbiB0aGUgYm90dG9tIHNpZGUgb2YgdGhlIG1hemVcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgJiYgbmV3WSAtIHBhdGhtYW5SYWRpdXMgPCAwKSB7XG4gICAgICBuZXdZID0gbWF6ZUhlaWdodCAtIHBhdGhtYW5SYWRpdXNcbiAgICB9XG5cbiAgICAvLyBJZiBnb2luZyBkb3duLCBzaG91bGQgd3JhcCB0byB0aGUgc2FtZSB5IHBvc2l0aW9uIG9uIHRoZSB0b3Agc2lkZSBvZiB0aGUgbWF6ZVxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZG93blwiICYmIG5ld1kgKyBwYXRobWFuUmFkaXVzID4gbWF6ZUhlaWdodCkge1xuICAgICAgbmV3WSA9IDAgKyBwYXRobWFuUmFkaXVzXG4gICAgfVxuXG4gICAgc3RhdGUucGF0aG1hbi54ID0gbmV3WFxuICAgIHN0YXRlLnBhdGhtYW4ueSA9IG5ld1lcbiAgICBzdGF0ZS5wYXRobWFuLmN1cnJlbnRDZWxsID0ge1xuICAgICAgeDogTWF0aC5mbG9vcihuZXdYIC8gY29uZmlnLmNlbGxTaXplKSxcbiAgICAgIHk6IE1hdGguZmxvb3IobmV3WSAvIGNvbmZpZy5jZWxsU2l6ZSksXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXBkYXRlR2hvc3RzID0gKCkgPT4ge1xuICAgIGNvbnN0IGdob3N0cyA9IHN0YXRlLmdob3N0c1xuXG4gICAgaWYgKCFzdGF0ZS5wYXRobWFuLmN1cnJlbnRDZWxsKSByZXR1cm5cblxuICAgIGdob3N0cy5mb3JFYWNoKChnaG9zdCwgaW5kZXgpID0+IHtcbiAgICAgIC8vIEZpcnN0LCBmaW5kIHRoZSBjZWxsIHRoYXQgZ2hvc3QgaXMgaW4gY3VycmVudGx5XG4gICAgICBjb25zdCBjZWxsWCA9IE1hdGguZmxvb3IoZ2hvc3QueCAvIGNvbmZpZy5jZWxsU2l6ZSlcbiAgICAgIGNvbnN0IGNlbGxZID0gTWF0aC5mbG9vcihnaG9zdC55IC8gY29uZmlnLmNlbGxTaXplKVxuICAgICAgY29uc3QgY3VycmVudENlbGwgPSB7IHg6IGNlbGxYLCB5OiBjZWxsWSB9XG4gICAgICBnaG9zdC5jdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsXG5cbiAgICAgIGlmIChnaG9zdC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnaG9zdC5wYXRoID0gZmluZFBhdGgoXG4gICAgICAgICAgeyB4OiBnaG9zdC5jdXJyZW50Q2VsbC54LCB5OiBnaG9zdC5jdXJyZW50Q2VsbC55IH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgeDogc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbCEueCB8fCAxLFxuICAgICAgICAgICAgeTogc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbCEueSB8fCAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlnLm1hemUuY2VsbHNcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlXG4gICAgICBjb25zdCBnaG9zdFJhZGl1cyA9IGNvbmZpZy5naG9zdHMuc2l6ZSAvIDJcbiAgICAgIGNvbnN0IG1hemUgPSBjb25maWcubWF6ZS5jZWxsc1xuXG4gICAgICBsZXQgbmV3WCA9IGdob3N0LnhcbiAgICAgIGxldCBuZXdZID0gZ2hvc3QueVxuXG4gICAgICAvLyBBZHZhbmNlIHRvd2FyZHMgdGhlIG5leHQgc3RlcCBpbiB0aGUgcGF0aFxuICAgICAgY29uc3QgY2FsY3VsYXRlRGlyZWN0aW9uID0gKFxuICAgICAgICBlbnRpdHk6IEVudGl0eSxcbiAgICAgICAgbmV4dFN0ZXA6IFBhdGhOb2RlXG4gICAgICApOiBEaXJlY3Rpb24gPT4ge1xuICAgICAgICAvLyBjaGVjayBmb3Igc2FtZSBjZWxsXG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXh0U3RlcC54ID09PSBlbnRpdHkuY3VycmVudENlbGwhLnggJiZcbiAgICAgICAgICBuZXh0U3RlcC55ID09PSBlbnRpdHkuY3VycmVudENlbGwhLnlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGVudGl0eS5kaXJlY3Rpb24hXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV4dCBjZWxsIGluIGFic29sdXRlIGNhbnZhcyBjb29yZGluYXRlc1xuICAgICAgICBjb25zdCBuZXh0Q2VsbENlbnRlclggPVxuICAgICAgICAgIG5leHRTdGVwLnggKiBjb25maWcuY2VsbFNpemUgKyBjb25maWcuY2VsbFNpemUgLyAyXG4gICAgICAgIGNvbnN0IG5leHRDZWxsQ2VudGVyWSA9XG4gICAgICAgICAgbmV4dFN0ZXAueSAqIGNvbmZpZy5jZWxsU2l6ZSArIGNvbmZpZy5jZWxsU2l6ZSAvIDJcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgaW4gY2VsbCBjb29yZGluYXRlcyBiZXR3ZWVuIHRoZSBlbnRpdHkncyBjdXJyZW50IGNlbGwgYW5kIHRoZSBuZXh0IHN0ZXBcbiAgICAgICAgY29uc3QgY2VsbERlbHRhWCA9IG5leHRTdGVwLnggLSBlbnRpdHkuY3VycmVudENlbGwhLnhcbiAgICAgICAgY29uc3QgY2VsbERlbHRhWSA9IG5leHRTdGVwLnkgLSBlbnRpdHkuY3VycmVudENlbGwhLnlcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHByaW1hcnkgYXhpcyBvZiBtb3ZlbWVudCBiYXNlZCBvbiB0aGUgbGFyZ2VyIGRlbHRhXG4gICAgICAgIGNvbnN0IHByaW1hcnlBeGlzID1cbiAgICAgICAgICBNYXRoLmFicyhjZWxsRGVsdGFYKSA+IE1hdGguYWJzKGNlbGxEZWx0YVkpID8gXCJ4XCIgOiBcInlcIlxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGRpcmVjdGlvbiBhcyBcIm5vbmVcIlxuICAgICAgICBsZXQgZGlyZWN0aW9uOiBEaXJlY3Rpb24gPSBcIm5vbmVcIlxuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBwcmltYXJ5IGF4aXMgYW5kIHRoZSBzaWduIG9mIHRoZSBkZWx0YVxuICAgICAgICBpZiAocHJpbWFyeUF4aXMgPT09IFwieFwiKSB7XG4gICAgICAgICAgZGlyZWN0aW9uID0gY2VsbERlbHRhWCA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IGNlbGxEZWx0YVkgPiAwID8gXCJkb3duXCIgOiBcInVwXCJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRpdHkuZGlyZWN0aW9uID09PSBcIm5vbmVcIikge1xuICAgICAgICAgIHJldHVybiBkaXJlY3Rpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbnRpdHkgaGFzIHJlYWNoZWQgdGhlIGNlbnRlciBvZiB0aGUgbmV4dCBjZWxsIGFsb25nIHRoZSBwcmltYXJ5IGF4aXMgb2YgbW92ZW1lbnRcbiAgICAgICAgLy8gSWYgbm90LCBjb250aW51ZSBpbiB0aGUgY3VycmVudCBkaXJlY3Rpb25cbiAgICAgICAgaWYgKGVudGl0eS5kaXJlY3Rpb24gPT09IFwicmlnaHRcIiAmJiBlbnRpdHkueCA8IG5leHRDZWxsQ2VudGVyWClcbiAgICAgICAgICByZXR1cm4gZW50aXR5LmRpcmVjdGlvbiFcbiAgICAgICAgaWYgKGVudGl0eS5kaXJlY3Rpb24gPT09IFwibGVmdFwiICYmIGVudGl0eS54ID4gbmV4dENlbGxDZW50ZXJYKVxuICAgICAgICAgIHJldHVybiBlbnRpdHkuZGlyZWN0aW9uIVxuICAgICAgICBpZiAoZW50aXR5LmRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmIGVudGl0eS55ID4gbmV4dENlbGxDZW50ZXJZKVxuICAgICAgICAgIHJldHVybiBlbnRpdHkuZGlyZWN0aW9uIVxuICAgICAgICBpZiAoZW50aXR5LmRpcmVjdGlvbiA9PT0gXCJkb3duXCIgJiYgZW50aXR5LnkgPCBuZXh0Q2VsbENlbnRlclkpXG4gICAgICAgICAgcmV0dXJuIGVudGl0eS5kaXJlY3Rpb24hXG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgZGlyZWN0aW9uIGlmIHRoZSBlbnRpdHkgaGFzIHJlYWNoZWQgdGhlIGNlbnRlciBvZiB0aGUgbmV4dCBjZWxsXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb25cbiAgICAgIH1cblxuICAgICAgaWYgKGdob3N0LnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZ2hvc3QucGF0aFswXS54ID09PSBnaG9zdC5jdXJyZW50Q2VsbC54ICYmXG4gICAgICAgICAgZ2hvc3QucGF0aFswXS55ID09PSBnaG9zdC5jdXJyZW50Q2VsbC55XG4gICAgICAgICkge1xuICAgICAgICAgIGdob3N0LnBhdGguc2hpZnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV4dFN0ZXA6IFBhdGhOb2RlID0gZ2hvc3QucGF0aFswXSEgLy8gR2V0IHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHBhdGhcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgZ2hvc3QgJHtpbmRleH0gbmV4dCBzdGVwYCwgbmV4dFN0ZXAueCwgbmV4dFN0ZXAueSwgZ2hvc3QuZGlyZWN0aW9uKVxuXG4gICAgICAgIGlmICghbmV4dFN0ZXApIHJldHVyblxuXG4gICAgICAgIGdob3N0LmRpcmVjdGlvbiA9IGNhbGN1bGF0ZURpcmVjdGlvbihnaG9zdCwgbmV4dFN0ZXApIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGRpcmVjdGlvbiBiYXNlZCBvbiB0aGUgbmV4dCBzdGVwXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBnaG9zdCAke2luZGV4fSBuZXcgZGlyZWN0aW9uYCwgZ2hvc3QuZGlyZWN0aW9uKVxuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlXG4gICAgICBpZiAoZ2hvc3QuZGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgbmV3WCArPSBjb25maWcuZ2hvc3RzLnNwZWVkXG4gICAgICB9XG4gICAgICBpZiAoZ2hvc3QuZGlyZWN0aW9uID09PSBcImxlZnRcIikge1xuICAgICAgICBuZXdYIC09IGNvbmZpZy5naG9zdHMuc3BlZWRcbiAgICAgIH1cbiAgICAgIGlmIChnaG9zdC5kaXJlY3Rpb24gPT09IFwidXBcIikge1xuICAgICAgICBuZXdZIC09IGNvbmZpZy5naG9zdHMuc3BlZWRcbiAgICAgIH1cbiAgICAgIGlmIChnaG9zdC5kaXJlY3Rpb24gPT09IFwiZG93blwiKSB7XG4gICAgICAgIG5ld1kgKz0gY29uZmlnLmdob3N0cy5zcGVlZFxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9uc1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2hvc3QuZGlyZWN0aW9uXG4gICAgICBsZXQgYWRqYWNlbnRDZWxsVHlwZVxuICAgICAgbGV0IGFkamFjZW50Q2VsbDogTm9kZSB8IHVuZGVmaW5lZFxuXG4gICAgICBsZXQgd2lsbENvbGlkZSA9IGZhbHNlXG5cbiAgICAgIGlmIChcbiAgICAgICAgZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgJiZcbiAgICAgICAgZ2hvc3QueCA+PSBjZWxsWCAqIGNvbmZpZy5jZWxsU2l6ZSArIGNvbmZpZy5jZWxsU2l6ZSAtIGdob3N0UmFkaXVzXG4gICAgICApIHtcbiAgICAgICAgYWRqYWNlbnRDZWxsVHlwZSA9IG1hemVbY2VsbFldPy5bY2VsbFggKyAxXVxuICAgICAgICBhZGphY2VudENlbGwgPSB7IHg6IGNlbGxYICsgMSwgeTogY2VsbFkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgJiZcbiAgICAgICAgZ2hvc3QueCA8PSBjZWxsWCAqIGNvbmZpZy5jZWxsU2l6ZSArIGdob3N0UmFkaXVzXG4gICAgICApIHtcbiAgICAgICAgYWRqYWNlbnRDZWxsVHlwZSA9IG1hemVbY2VsbFldPy5bY2VsbFggLSAxXVxuICAgICAgICBhZGphY2VudENlbGwgPSB7IHg6IGNlbGxYIC0gMSwgeTogY2VsbFkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmXG4gICAgICAgIGdob3N0LnkgPD0gY2VsbFkgKiBjb25maWcuY2VsbFNpemUgKyBnaG9zdFJhZGl1c1xuICAgICAgKSB7XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPSBtYXplW2NlbGxZIC0gMV0/LltjZWxsWF1cbiAgICAgICAgYWRqYWNlbnRDZWxsID0geyB4OiBjZWxsWCwgeTogY2VsbFkgLSAxIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBkaXJlY3Rpb24gPT09IFwiZG93blwiICYmXG4gICAgICAgIGdob3N0LnkgPj0gY2VsbFkgKiBjb25maWcuY2VsbFNpemUgKyBjb25maWcuY2VsbFNpemUgLSBnaG9zdFJhZGl1c1xuICAgICAgKSB7XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPSBtYXplW2NlbGxZICsgMV0/LltjZWxsWF1cbiAgICAgICAgYWRqYWNlbnRDZWxsID0geyB4OiBjZWxsWCwgeTogY2VsbFkgKyAxIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aCB3YWxsc1xuICAgICAgaWYgKFxuICAgICAgICBhZGphY2VudENlbGxUeXBlID09PSBDZWxsVHlwZS5XYWxsSG9yaXpvbnRhbCB8fFxuICAgICAgICBhZGphY2VudENlbGxUeXBlID09PSBDZWxsVHlwZS5XYWxsVmVydGljYWwgfHxcbiAgICAgICAgYWRqYWNlbnRDZWxsVHlwZSA9PT0gQ2VsbFR5cGUuV2FsbENvcm5lckJvdHRvbUxlZnQgfHxcbiAgICAgICAgYWRqYWNlbnRDZWxsVHlwZSA9PT0gQ2VsbFR5cGUuV2FsbENvcm5lckJvdHRvbVJpZ2h0IHx8XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPT09IENlbGxUeXBlLldhbGxDb3JuZXJUb3BMZWZ0IHx8XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPT09IENlbGxUeXBlLldhbGxDb3JuZXJUb3BSaWdodFxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBnaG9zdCBjb2xsaWRlZCB3aXRoIHdhbGxgKVxuICAgICAgICB3aWxsQ29saWRlID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGFkamFjZW50Q2VsbD8ueCA9PT0gc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbD8ueCAmJlxuICAgICAgICBhZGphY2VudENlbGw/LnkgPT09IHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGw/LnlcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLmxvZyhgZ2hvc3QgY29sbGlkZWQgd2l0aCBwYXRobWFuYClcbiAgICAgICAgd2lsbENvbGlkZSA9IHRydWVcbiAgICAgICAgc3RhdGUucGhhc2UgPSBcImdhbWUtb3ZlclwiXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG90aGVyR2hvc3RzID0gZ2hvc3RzLmZpbHRlcigoZykgPT4gZy5pZCAhPT0gZ2hvc3QuaWQpXG4gICAgICBvdGhlckdob3N0cy5mb3JFYWNoKChvdGhlckdob3N0KSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhZGphY2VudENlbGw/LnggPT09IG90aGVyR2hvc3QuY3VycmVudENlbGwhLnggJiZcbiAgICAgICAgICBhZGphY2VudENlbGw/LnkgPT09IG90aGVyR2hvc3QuY3VycmVudENlbGwhLnlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGdob3N0IGNvbGxpZGVkIHdpdGggYW5vdGhlciBnaG9zdGApXG4gICAgICAgICAgd2lsbENvbGlkZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKHdpbGxDb2xpZGUpIHtcbiAgICAgICAgZ2hvc3QuaXNNb3ZpbmcgPSBmYWxzZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgd3JhcHBpbmcgYXJvdW5kIHRoZSBtYXplXG4gICAgICBjb25zdCB7IHg6IG1hemVXaWR0aCwgeTogbWF6ZUhlaWdodCB9ID0gY2FsY3VsYXRlTWF6ZURpbWVuc2lvbnMoKVxuXG4gICAgICAvLyBJZiBnb2luZyByaWdodCwgc2hvdWxkIHdyYXAgdG8gdGhlIHNhbWUgeCBwb3NpdGlvbiBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBtYXplXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgJiYgbmV3WCArIGdob3N0UmFkaXVzID4gbWF6ZVdpZHRoKSB7XG4gICAgICAgIG5ld1ggPSAwICsgZ2hvc3RSYWRpdXNcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZ29pbmcgbGVmdCwgc2hvdWxkIHdyYXAgdG8gdGhlIHNhbWUgeCBwb3NpdGlvbiBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbWF6ZVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgJiYgbmV3WCAtIGdob3N0UmFkaXVzIDwgMCkge1xuICAgICAgICBuZXdYID0gbWF6ZVdpZHRoIC0gZ2hvc3RSYWRpdXNcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZ29pbmcgdXAsIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHkgcG9zaXRpb24gb24gdGhlIGJvdHRvbSBzaWRlIG9mIHRoZSBtYXplXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgJiYgbmV3WSAtIGdob3N0UmFkaXVzIDwgMCkge1xuICAgICAgICBuZXdZID0gbWF6ZUhlaWdodCAtIGdob3N0UmFkaXVzXG4gICAgICB9XG5cbiAgICAgIC8vIElmIGdvaW5nIGRvd24sIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHkgcG9zaXRpb24gb24gdGhlIHRvcCBzaWRlIG9mIHRoZSBtYXplXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIiAmJiBuZXdZICsgZ2hvc3RSYWRpdXMgPiBtYXplSGVpZ2h0KSB7XG4gICAgICAgIG5ld1kgPSAwICsgZ2hvc3RSYWRpdXNcbiAgICAgIH1cblxuICAgICAgZ2hvc3QueCA9IG5ld1hcbiAgICAgIGdob3N0LnkgPSBuZXdZXG4gICAgICBnaG9zdC5jdXJyZW50Q2VsbCA9IHtcbiAgICAgICAgeDogTWF0aC5mbG9vcihuZXdYIC8gY29uZmlnLmNlbGxTaXplKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcihuZXdZIC8gY29uZmlnLmNlbGxTaXplKSxcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBnaG9zdC5jdXJyZW50Q2VsbC54ICE9PSBjdXJyZW50Q2VsbC54IHx8XG4gICAgICAgIGdob3N0LmN1cnJlbnRDZWxsLnkgIT09IGN1cnJlbnRDZWxsLnlcbiAgICAgICkge1xuICAgICAgICBnaG9zdC5wYXRoID0gZmluZFBhdGgoXG4gICAgICAgICAgeyB4OiBnaG9zdC5jdXJyZW50Q2VsbC54LCB5OiBnaG9zdC5jdXJyZW50Q2VsbC55IH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgeDogc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbD8ueCB8fCAxLFxuICAgICAgICAgICAgeTogc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbD8ueSB8fCAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlnLm1hemUuY2VsbHNcbiAgICAgICAgKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgZ2hvc3QgJHtpbmRleH0gcmVzZXQgcGF0aGAsIGdob3N0LnBhdGhbMF0pXG4gICAgICB9XG5cbiAgICAgIC8vIFBlcmlvZGljYWxseSBvciB3aGVuIFBhdGhtYW4gbW92ZXMsIHVwZGF0ZSB0aGUgZ2hvc3QncyBwYXRoXG4gICAgICAvLyBpZiAoc2hvdWxkVXBkYXRlUGF0aChnaG9zdCkpIHtcbiAgICAgIC8vIGNvbnN0IHBhdGhzID0gZ2V0VG9wUGF0aHMoZ2hvc3QsIHN0YXRlLnBhdGhtYW4sIGNvbmZpZy5tYXplLmNlbGxzLCAzKTsgLy8gR2V0IHRvcCAzIHBhdGhzXG4gICAgICAvLyBjb25zdCBjaG9zZW5QYXRoID0gcGF0aHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGF0aHMubGVuZ3RoKV07IC8vIFJhbmRvbWx5IGNob29zZSBvbmVcbiAgICAgIC8vIGdob3N0LnBhdGggPSBjaG9zZW5QYXRoO1xuXG4gICAgICAvLyBTZXQgdGhlIG5leHQgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBwYXRoXG4gICAgICBpZiAoZ2hvc3QucGF0aD8ubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjb25zdCBuZXh0U3RlcCA9IGdob3N0LnBhdGguc2hpZnQoKSAvLyBHZXQgdGhlIG5leHQgc3RlcCBpbiB0aGUgcGF0aFxuICAgICAgICAvLyBnaG9zdC5kaXJlY3Rpb24gPSBjYWxjdWxhdGVEaXJlY3Rpb24oZ2hvc3QsIG5leHRTdGVwKSAvLyBDYWxjdWxhdGUgdGhlIG5ldyBkaXJlY3Rpb24gYmFzZWQgb24gdGhlIG5leHQgc3RlcFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25zdCB1cGRhdGVQZWxsZXRzID0gKCkgPT4ge1xuICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zXG4gICAgY29uc3QgcGF0aG1hblJhZGl1cyA9IGNvbmZpZy5wYXRobWFuLnNpemUgLyAyXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnBlbGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBlbGxldCA9IHN0YXRlLnBlbGxldHNbaV1cbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzdGF0ZS5wYXRobWFuLnggLSBwZWxsZXQueCwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHN0YXRlLnBhdGhtYW4ueSAtIHBlbGxldC55LCAyKVxuICAgICAgKVxuXG4gICAgICBpZiAoZGlzdGFuY2UgPCBwYXRobWFuUmFkaXVzICsgY29uZmlnLnBlbGxldHMuc2l6ZSkge1xuICAgICAgICBzdGF0ZS5wZWxsZXRzLnNwbGljZShpLCAxKVxuICAgICAgICBpLS1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnBvd2VyUGVsbGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGVsbGV0ID0gc3RhdGUucG93ZXJQZWxsZXRzW2ldXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coc3RhdGUucGF0aG1hbi54IC0gcGVsbGV0LngsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhzdGF0ZS5wYXRobWFuLnkgLSBwZWxsZXQueSwgMilcbiAgICAgIClcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgcGF0aG1hblJhZGl1cyArIGNvbmZpZy5wb3dlclBlbGxldHMuc2l6ZSkge1xuICAgICAgICBzdGF0ZS5wb3dlclBlbGxldHMuc3BsaWNlKGksIDEpXG4gICAgICAgIGktLVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVN0YXRzID0gKGRlbHRhVGltZTogbnVtYmVyKSA9PiB7XG4gICAgc3RhdGUuY3VycmVudEZQUyA9IDEwMDAgLyBkZWx0YVRpbWVcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZVJlc2l6ZSA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAvLyBSZXNpemUgdGhlIGNhbnZhc1xuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuXG4gICAgY2FsY3VsYXRlU2NhbGUoKVxuICAgIGRyYXcoKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlS2V5VXAgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09IFwiZ2FtZS1vdmVyXCIgfHwgc3RhdGUucGhhc2UgPT09IFwiZ2FtZS13b25cIikgcmV0dXJuXG5cbiAgICAvLyBUb2dnbGUgcGF1c2VcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIiBcIikge1xuICAgICAgc3RhdGUucGhhc2UgPSBzdGF0ZS5waGFzZSA9PT0gXCJwYXVzZWRcIiA/IFwicGxheWluZ1wiIDogXCJwYXVzZWRcIlxuXG4gICAgICBpZiAoc3RhdGUucGhhc2UgPT09IFwicGF1c2VkXCIpIHtcbiAgICAgICAgc3RhdGUub3ZlcmxheVRleHQgPSBjb25maWcub3ZlcmxheU1lc3NhZ2VzLnBhdXNlZFxuICAgICAgICBkcmF3T3ZlcmxheSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vdmVybGF5VGV4dCA9IFwiXCJcbiAgICAgICAgLy8gSWYgdW5wYXVzaW5nLCByZS1zdGFydCB0aGUgYW5pbWF0aW9uIGxvb3BcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSBcInBhdXNlZFwiKSByZXR1cm5cblxuICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dSaWdodFwiIHx8IGV2ZW50LmtleSA9PT0gXCJkXCIpIHtcbiAgICAgIHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uID0gXCJyaWdodFwiXG4gICAgICBzdGF0ZS5wYXRobWFuLmlzTW92aW5nID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dMZWZ0XCIgfHwgZXZlbnQua2V5ID09PSBcImFcIikge1xuICAgICAgc3RhdGUucGF0aG1hbi5kaXJlY3Rpb24gPSBcImxlZnRcIlxuICAgICAgc3RhdGUucGF0aG1hbi5pc01vdmluZyA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93VXBcIiB8fCBldmVudC5rZXkgPT09IFwid1wiKSB7XG4gICAgICBzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9IFwidXBcIlxuICAgICAgc3RhdGUucGF0aG1hbi5pc01vdmluZyA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiIHx8IGV2ZW50LmtleSA9PT0gXCJzXCIpIHtcbiAgICAgIHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uID0gXCJkb3duXCJcbiAgICAgIHN0YXRlLnBhdGhtYW4uaXNNb3ZpbmcgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCBjbGlja0xvY2F0aW9uID0ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdGF0ZS5kZWJ1Zy5jbGlja0xvY2F0aW9uID0gbnVsbFxuICAgIH0sIDQwMDApXG5cbiAgICBzdGF0ZS5kZWJ1Zy5jbGlja0xvY2F0aW9uID0gY2xpY2tMb2NhdGlvblxuXG4gICAgY29uc3QgcmVzZXRCdXR0b24gPSB7XG4gICAgICB4OiBjYW52YXMud2lkdGggLSAxMjAsXG4gICAgICB5OiA4NixcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDMwLFxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV2ZW50LmNsaWVudFggPj0gcmVzZXRCdXR0b24ueCAmJlxuICAgICAgZXZlbnQuY2xpZW50WCA8PSByZXNldEJ1dHRvbi54ICsgcmVzZXRCdXR0b24ud2lkdGggJiZcbiAgICAgIGV2ZW50LmNsaWVudFkgPj0gcmVzZXRCdXR0b24ueSAmJlxuICAgICAgZXZlbnQuY2xpZW50WSA8PSByZXNldEJ1dHRvbi55ICsgcmVzZXRCdXR0b24uaGVpZ2h0XG4gICAgKSB7XG4gICAgICByZXNldCgpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXR0YWNoRXZlbnRzID0gKCkgPT4ge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGhhbmRsZUtleVVwKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spXG4gIH1cblxuICBjb25zdCBkZXRhY2hFdmVudHMgPSAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgaGFuZGxlS2V5VXApXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljaylcbiAgfVxuXG4gIGNvbnN0IGFuaW1hdGUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBwcmV2aW91cyB0aW1lc3RhbXBcbiAgICBpZiAoc3RhdGUucHJldmlvdXNBbmltYXRpb25UaW1lc3RhbXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdGUucHJldmlvdXNBbmltYXRpb25UaW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGVsdGFUaW1lID0gdGltZXN0YW1wIC0gc3RhdGUucHJldmlvdXNBbmltYXRpb25UaW1lc3RhbXBcblxuICAgIC8vIFVwZGF0ZSBzdHVmZlxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgIHVwZGF0ZVBhdGhtYW4oKVxuICAgICAgdXBkYXRlR2hvc3RzKClcbiAgICAgIHVwZGF0ZVBlbGxldHMoKVxuICAgICAgdXBkYXRlU3RhdHMoZGVsdGFUaW1lKVxuICAgIH1cblxuICAgIC8vIERyYXcgc3R1ZmZcbiAgICBkcmF3KClcblxuICAgIHN0YXRlLnByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wID0gdGltZXN0YW1wXG5cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09IFwicGF1c2VkXCIpIHJldHVyblxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gIH1cblxuICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJTdGFydGluZyBQYXRobWFuIGdhbWUuLi5cIiwgY2FudmFzKVxuXG4gICAgaW5pdCgpXG4gICAgYXR0YWNoRXZlbnRzKClcbiAgICBkcmF3KClcblxuICAgIC8vIGZpcmUgYSByZXNpemUgZXZlbnRcbiAgICBjb25zdCByZXNpemVFdmVudCA9IG5ldyBFdmVudChcInJlc2l6ZVwiKVxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHJlc2l6ZUV2ZW50KVxuXG4gICAgLy8gU3RhcnQgdGhlIGFuaW1hdGlvbiBsb29wXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gIH1cblxuICBjb25zdCBxdWl0ID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiU3RvcHBpbmcgUGF0aG1hbiBnYW1lLi4uXCIpXG5cbiAgICBzdGF0ZS5wcmV2aW91c0FuaW1hdGlvblRpbWVzdGFtcCA9IHVuZGVmaW5lZFxuICAgIGRldGFjaEV2ZW50cygpXG4gIH1cblxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlJlc2V0dGluZyBQYXRobWFuIGdhbWUuLi5cIilcbiAgICBxdWl0KClcbiAgICBzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpXG4gICAgcnVuKClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcnVuLFxuICAgIHF1aXQsXG4gICAgcmVzZXQsXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2FtZVxuIl0sIm5hbWVzIjpbIkNlbGxUeXBlIiwiY29uZmlnIiwiY2FsY3VsYXRlTWF6ZURpbWVuc2lvbnMiLCJnZXRJbml0aWFsU3RhdGUiLCJ1c2VEcmF3IiwiYVN0YXIiLCJmaW5kUGF0aCIsImdhbWUiLCJjYW52YXMiLCJzdGF0ZSIsImRyYXciLCJkcmF3T3ZlcmxheSIsImluaXQiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImNhbGN1bGF0ZVNjYWxlIiwic2NhbGUiLCJ1cGRhdGVQYXRobWFuIiwiY2VsbFgiLCJNYXRoIiwiZmxvb3IiLCJwYXRobWFuIiwieCIsImNlbGxTaXplIiwiY2VsbFkiLCJ5IiwiY3VycmVudENlbGwiLCJpc01vdmluZyIsIm1vdXRoU3BlZWQiLCJtYXhMb3dlc3RBbmdsZSIsIm1vdXRoT3BlbmluZyIsIm1vdXRoQW5nbGUiLCJkaXJlY3Rpb24iLCJuZXdYIiwibmV3WSIsInNwZWVkIiwicGF0aG1hblJhZGl1cyIsInNpemUiLCJtYXplIiwiY2VsbHMiLCJkZWJ1ZyIsImN1cnJlbnRQYXRobWFuUG9zaXRpb24iLCJhZGphY2VudENlbGwiLCJ3aWxsQ29saWRlIiwiV2FsbEhvcml6b250YWwiLCJXYWxsVmVydGljYWwiLCJXYWxsQ29ybmVyVG9wTGVmdCIsIldhbGxDb3JuZXJUb3BSaWdodCIsIldhbGxDb3JuZXJCb3R0b21MZWZ0IiwiV2FsbENvcm5lckJvdHRvbVJpZ2h0IiwibWF6ZVdpZHRoIiwibWF6ZUhlaWdodCIsInVwZGF0ZUdob3N0cyIsImdob3N0cyIsImZvckVhY2giLCJnaG9zdCIsImluZGV4IiwicGF0aCIsImxlbmd0aCIsImdob3N0UmFkaXVzIiwiY2FsY3VsYXRlRGlyZWN0aW9uIiwiZW50aXR5IiwibmV4dFN0ZXAiLCJuZXh0Q2VsbENlbnRlclgiLCJuZXh0Q2VsbENlbnRlclkiLCJjZWxsRGVsdGFYIiwiY2VsbERlbHRhWSIsInByaW1hcnlBeGlzIiwiYWJzIiwic2hpZnQiLCJhZGphY2VudENlbGxUeXBlIiwiY29uc29sZSIsImxvZyIsInBoYXNlIiwib3RoZXJHaG9zdHMiLCJmaWx0ZXIiLCJnIiwiaWQiLCJvdGhlckdob3N0IiwidXBkYXRlUGVsbGV0cyIsImkiLCJwZWxsZXRzIiwicGVsbGV0IiwiZGlzdGFuY2UiLCJzcXJ0IiwicG93Iiwic3BsaWNlIiwicG93ZXJQZWxsZXRzIiwidXBkYXRlU3RhdHMiLCJkZWx0YVRpbWUiLCJjdXJyZW50RlBTIiwiaGFuZGxlUmVzaXplIiwiZXZlbnQiLCJoYW5kbGVLZXlVcCIsImtleSIsIm92ZXJsYXlUZXh0Iiwib3ZlcmxheU1lc3NhZ2VzIiwicGF1c2VkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsImhhbmRsZUNsaWNrIiwiY2xpY2tMb2NhdGlvbiIsImNsaWVudFgiLCJjbGllbnRZIiwic2V0VGltZW91dCIsInJlc2V0QnV0dG9uIiwicmVzZXQiLCJhdHRhY2hFdmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRpbWVzdGFtcCIsInByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wIiwidW5kZWZpbmVkIiwicnVuIiwicmVzaXplRXZlbnQiLCJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJxdWl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pathman/game.ts\n"));

/***/ })

});