/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdavidchapman%2FCode%2Fpathman%2Fpages%2Findex.tsx&page=%2F!":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdavidchapman%2FCode%2Fpathman%2Fpages%2Findex.tsx&page=%2F! ***!
  \**************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmRhdmlkY2hhcG1hbiUyRkNvZGUlMkZwYXRobWFuJTJGcGFnZXMlMkZpbmRleC50c3gmcGFnZT0lMkYhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsNENBQW1CO0FBQzFDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz85N2YwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9wYWdlcy9pbmRleC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdavidchapman%2FCode%2Fpathman%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Index; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _pathman__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pathman */ \"./pathman/index.ts\");\n\n\n\nfunction Index() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_pathman__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n        fileName: \"/Users/davidchapman/Code/pathman/pages/index.tsx\",\n        lineNumber: 5,\n        columnNumber: 10\n    }, this);\n}\n_c = Index;\nvar _c;\n$RefreshReg$(_c, \"Index\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5QjtBQUNNO0FBRWhCLFNBQVNFO0lBQ3RCLHFCQUFPLDhEQUFDRCxnREFBTUE7Ozs7O0FBQ2hCO0tBRndCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC50c3g/MDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCBQYWNtYW4gZnJvbSBcIi4uL3BhdGhtYW5cIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbmRleCgpIHtcbiAgcmV0dXJuIDxQYWNtYW4gLz5cbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlBhY21hbiIsIkluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.tsx\n"));

/***/ }),

/***/ "./pathman/component.tsx":
/*!*******************************!*\
  !*** ./pathman/component.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game */ \"./pathman/game.ts\");\n\nvar _s = $RefreshSig$();\n\n\nconst PathmanComponent = ()=>{\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const canvas = canvasRef.current;\n        const pathman = (0,_game__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(canvas);\n        pathman.run();\n        return ()=>{\n            pathman.quit();\n        };\n    }, [\n        canvasRef.current\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        id: \"pathman\",\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/davidchapman/Code/pathman/pathman/component.tsx\",\n        lineNumber: 19,\n        columnNumber: 10\n    }, undefined);\n};\n_s(PathmanComponent, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = PathmanComponent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (PathmanComponent);\nvar _c;\n$RefreshReg$(_c, \"PathmanComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL2NvbXBvbmVudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDUDtBQUVsQyxNQUFNRyxtQkFBbUI7O0lBQ3ZCLE1BQU1DLFlBQVlKLDZDQUFNQSxDQUFDO0lBRXpCQyxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ0csVUFBVUMsT0FBTyxFQUFFO1FBRXhCLE1BQU1DLFNBQVNGLFVBQVVDLE9BQU87UUFDaEMsTUFBTUUsVUFBVUwsaURBQWFBLENBQUNJO1FBQzlCQyxRQUFRQyxHQUFHO1FBRVgsT0FBTztZQUNMRCxRQUFRRSxJQUFJO1FBQ2Q7SUFDRixHQUFHO1FBQUNMLFVBQVVDLE9BQU87S0FBQztJQUV0QixxQkFBTyw4REFBQ0M7UUFBT0ksSUFBRztRQUFVQyxLQUFLUDs7Ozs7O0FBQ25DO0dBaEJNRDtLQUFBQTtBQWtCTiwrREFBZUEsZ0JBQWdCQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhdGhtYW4vY29tcG9uZW50LnRzeD8xNTE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCBjcmVhdGVQYXRobWFuIGZyb20gXCIuL2dhbWVcIlxuXG5jb25zdCBQYXRobWFuQ29tcG9uZW50ID0gKCkgPT4ge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWYobnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBjb25zdCBwYXRobWFuID0gY3JlYXRlUGF0aG1hbihjYW52YXMpXG4gICAgcGF0aG1hbi5ydW4oKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBhdGhtYW4ucXVpdCgpXG4gICAgfVxuICB9LCBbY2FudmFzUmVmLmN1cnJlbnRdKVxuXG4gIHJldHVybiA8Y2FudmFzIGlkPVwicGF0aG1hblwiIHJlZj17Y2FudmFzUmVmfSAvPlxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXRobWFuQ29tcG9uZW50XG4iXSwibmFtZXMiOlsidXNlUmVmIiwidXNlRWZmZWN0IiwiY3JlYXRlUGF0aG1hbiIsIlBhdGhtYW5Db21wb25lbnQiLCJjYW52YXNSZWYiLCJjdXJyZW50IiwiY2FudmFzIiwicGF0aG1hbiIsInJ1biIsInF1aXQiLCJpZCIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pathman/component.tsx\n"));

/***/ }),

/***/ "./pathman/config.ts":
/*!***************************!*\
  !*** ./pathman/config.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mazes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mazes */ \"./pathman/mazes.ts\");\n\nconst config = {\n    pathman: {\n        speed: 1.5,\n        startX: 30,\n        startY: 30,\n        startDirection: \"none\",\n        size: 18,\n        mouthSpeed: 0.1,\n        maxLowestAngle: -0.6\n    },\n    ghosts: {\n        speed: 1,\n        size: 20\n    },\n    cellSize: 20,\n    colors: {\n        primary: \"yellow\",\n        background: \"black\",\n        text: \"yellow\",\n        secondaryText: \"black\",\n        wall: \"blue\"\n    },\n    pellets: {\n        size: 2\n    },\n    powerPellets: {\n        size: 6\n    },\n    sidebarWidth: 120,\n    overlayMessages: {\n        paused: \"Paused. Press spacebar to continue.\",\n        gameOver: \"Game over. Refresh to play again.\",\n        gameWon: \"You won! Refresh to play again.\"\n    },\n    maze: _mazes__WEBPACK_IMPORTED_MODULE_0__.defaultMaze,\n    wallWidth: 2,\n    showGrid: true,\n    showRulers: true\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL2NvbmZpZy50cyIsIm1hcHBpbmdzIjoiOztBQUFxQztBQUdyQyxNQUFNQyxTQUFxQjtJQUN6QkMsU0FBUztRQUNQQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxnQkFBZ0I7UUFDaEJDLE1BQU07UUFDTkMsWUFBWTtRQUNaQyxnQkFBZ0IsQ0FBQztJQUNuQjtJQUNBQyxRQUFRO1FBQ05QLE9BQU87UUFDUEksTUFBTTtJQUNSO0lBQ0FJLFVBQVU7SUFDVkMsUUFBUTtRQUNOQyxTQUFTO1FBQ1RDLFlBQVk7UUFDWkMsTUFBTTtRQUNOQyxlQUFlO1FBQ2ZDLE1BQU07SUFDUjtJQUNBQyxTQUFTO1FBQ1BYLE1BQU07SUFDUjtJQUNBWSxjQUFjO1FBQ1paLE1BQU07SUFDUjtJQUNBYSxjQUFjO0lBQ2RDLGlCQUFpQjtRQUNmQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsU0FBUztJQUNYO0lBQ0FDLE1BQU16QiwrQ0FBV0E7SUFDakIwQixXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsWUFBWTtBQUNkO0FBRUEsK0RBQWUzQixNQUFNQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhdGhtYW4vY29uZmlnLnRzP2ViY2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdE1hemUgfSBmcm9tIFwiLi9tYXplc1wiXG5pbXBvcnQgeyBHYW1lQ29uZmlnIH0gZnJvbSBcIi4vdHlwZXNcIlxuXG5jb25zdCBjb25maWc6IEdhbWVDb25maWcgPSB7XG4gIHBhdGhtYW46IHtcbiAgICBzcGVlZDogMS41LFxuICAgIHN0YXJ0WDogMzAsXG4gICAgc3RhcnRZOiAzMCxcbiAgICBzdGFydERpcmVjdGlvbjogXCJub25lXCIsXG4gICAgc2l6ZTogMTgsXG4gICAgbW91dGhTcGVlZDogMC4xLFxuICAgIG1heExvd2VzdEFuZ2xlOiAtMC42LFxuICB9LFxuICBnaG9zdHM6IHtcbiAgICBzcGVlZDogMSxcbiAgICBzaXplOiAyMCxcbiAgfSxcbiAgY2VsbFNpemU6IDIwLFxuICBjb2xvcnM6IHtcbiAgICBwcmltYXJ5OiBcInllbGxvd1wiLFxuICAgIGJhY2tncm91bmQ6IFwiYmxhY2tcIixcbiAgICB0ZXh0OiBcInllbGxvd1wiLFxuICAgIHNlY29uZGFyeVRleHQ6IFwiYmxhY2tcIixcbiAgICB3YWxsOiBcImJsdWVcIixcbiAgfSxcbiAgcGVsbGV0czoge1xuICAgIHNpemU6IDIsXG4gIH0sXG4gIHBvd2VyUGVsbGV0czoge1xuICAgIHNpemU6IDYsXG4gIH0sXG4gIHNpZGViYXJXaWR0aDogMTIwLFxuICBvdmVybGF5TWVzc2FnZXM6IHtcbiAgICBwYXVzZWQ6IFwiUGF1c2VkLiBQcmVzcyBzcGFjZWJhciB0byBjb250aW51ZS5cIixcbiAgICBnYW1lT3ZlcjogXCJHYW1lIG92ZXIuIFJlZnJlc2ggdG8gcGxheSBhZ2Fpbi5cIixcbiAgICBnYW1lV29uOiBcIllvdSB3b24hIFJlZnJlc2ggdG8gcGxheSBhZ2Fpbi5cIixcbiAgfSxcbiAgbWF6ZTogZGVmYXVsdE1hemUsXG4gIHdhbGxXaWR0aDogMixcbiAgc2hvd0dyaWQ6IHRydWUsXG4gIHNob3dSdWxlcnM6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZ1xuIl0sIm5hbWVzIjpbImRlZmF1bHRNYXplIiwiY29uZmlnIiwicGF0aG1hbiIsInNwZWVkIiwic3RhcnRYIiwic3RhcnRZIiwic3RhcnREaXJlY3Rpb24iLCJzaXplIiwibW91dGhTcGVlZCIsIm1heExvd2VzdEFuZ2xlIiwiZ2hvc3RzIiwiY2VsbFNpemUiLCJjb2xvcnMiLCJwcmltYXJ5IiwiYmFja2dyb3VuZCIsInRleHQiLCJzZWNvbmRhcnlUZXh0Iiwid2FsbCIsInBlbGxldHMiLCJwb3dlclBlbGxldHMiLCJzaWRlYmFyV2lkdGgiLCJvdmVybGF5TWVzc2FnZXMiLCJwYXVzZWQiLCJnYW1lT3ZlciIsImdhbWVXb24iLCJtYXplIiwid2FsbFdpZHRoIiwic2hvd0dyaWQiLCJzaG93UnVsZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pathman/config.ts\n"));

/***/ }),

/***/ "./pathman/draw.ts":
/*!*************************!*\
  !*** ./pathman/draw.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./pathman/types.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./pathman/config.ts\");\n\n\nconst useDraw = (canvas, state)=>{\n    const ctx = canvas.getContext(\"2d\");\n    const backgroundCanvas = document.createElement(\"canvas\");\n    backgroundCanvas.width = canvas.width;\n    backgroundCanvas.height = canvas.height;\n    const backgroundCtx = backgroundCanvas.getContext(\"2d\");\n    let mazePosition = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    };\n    const drawBackground = ()=>{\n        backgroundCtx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.background;\n        ctx.fillRect(0, 0, window.innerWidth / state.scale, window.innerHeight / state.scale);\n    };\n    const calculateMazePosition = ()=>{\n        const mazeWidth = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells[0].length * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize;\n        const mazeHeight = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells.length * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize;\n        return {\n            x: canvas.width / 2,\n            y: canvas.height / 2 + mazeHeight / 2,\n            width: mazeWidth,\n            height: mazeHeight\n        };\n    };\n    mazePosition = calculateMazePosition();\n    window.addEventListener(\"resize\", ()=>{\n        mazePosition = calculateMazePosition();\n    });\n    window.document.addEventListener(\"DOMContentLoaded\", ()=>{\n        mazePosition = calculateMazePosition();\n    });\n    const drawMaze = ()=>{\n        const cellSize = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize;\n        const cells = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells;\n        ctx.save();\n        ctx.translate(mazePosition.x, mazePosition.y);\n        cells.forEach((row, y)=>{\n            row.forEach((cell, x)=>{\n                const cellX = x * cellSize;\n                const cellY = y * cellSize;\n                if (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].showGrid) {\n                    // draw a box around each cell\n                    ctx.strokeStyle = \"green\";\n                    ctx.lineWidth = 1;\n                    ctx.strokeRect(cellX, cellY, cellSize, cellSize);\n                }\n                if (cell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallHorizontal) {\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.wall;\n                    ctx.fillRect(cellX, cellY + (cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellSize, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth);\n                }\n                if (cell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallVertical) {\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.wall;\n                    ctx.fillRect(cellX + (cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth, cellSize);\n                }\n                if (cell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopLeft) {\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.wall;\n                    ctx.fillRect(cellX + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth);\n                    ctx.fillRect(cellX + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2);\n                }\n                if (cell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopRight) {\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.wall;\n                    ctx.fillRect(cellX, cellY + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth);\n                    ctx.fillRect(cellX + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2);\n                }\n                if (cell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomLeft) {\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.wall;\n                    ctx.fillRect(cellX + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2);\n                    ctx.fillRect(cellX + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth);\n                }\n                if (cell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomRight) {\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.wall;\n                    ctx.fillRect(cellX, cellY + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth);\n                    ctx.fillRect(cellX + (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 - _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2), cellY, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2 + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].wallWidth / 2);\n                }\n            });\n        });\n        ctx.restore();\n    };\n    const drawRulers = ()=>{\n        const padding = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize;\n        ctx.save();\n        ctx.translate(mazePosition.x - padding, mazePosition.y - padding);\n        ctx.strokeStyle = \"red\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(mazePosition.width + padding * 2, 0);\n        ctx.stroke();\n        // add numbers for x cells, 1 above each cell\n        ctx.fillStyle = \"red\";\n        _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells[0].forEach((cell, x)=>{\n            ctx.fillText(x.toString(), _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + x * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 4, -padding / 2);\n        });\n        ctx.fill();\n        ctx.strokeStyle = \"green\";\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, mazePosition.height + padding * 2);\n        ctx.stroke();\n        // add numbers for y cells, 1 left of each cell\n        ctx.fillStyle = \"green\";\n        _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells.forEach((row, y)=>{\n            ctx.fillText(y.toString(), -padding, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + y * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2);\n        });\n        ctx.fill();\n        ctx.restore();\n    };\n    const drawEntityRelativeToMaze = (drawFunction)=>{\n        ctx.save();\n        ctx.translate(mazePosition.x, mazePosition.y);\n        drawFunction();\n        ctx.restore();\n    };\n    const drawStats = ()=>{\n        const boxPadding = 10;\n        // Box dimensions and position\n        const boxWidth = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].sidebarWidth - boxPadding;\n        const boxHeight = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].sidebarWidth - boxPadding;\n        const boxX = ctx.canvas.width - boxWidth - boxPadding;\n        const boxY = boxPadding;\n        ctx.strokeStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.primary;\n        ctx.lineWidth = 2;\n        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);\n        ctx.font = \"16px Helvetica, Arial, sans-serif\";\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.primary;\n        ctx.lineWidth = 2;\n        const textX = boxX + boxPadding;\n        const textY = boxY + (boxHeight - 50) / 2;\n        ctx.textAlign = \"left\";\n        ctx.fillText(\"FPS: \".concat(state.currentFPS.toFixed(0)), textX, textY);\n        ctx.fillText(\"Pellets: \".concat(state.pellets.length), textX, textY + boxPadding * 2);\n        // Add reset button\n        const buttonX = boxX + boxPadding;\n        const buttonY = textY + (boxPadding * 2 + 20);\n        const buttonWidth = boxWidth - boxPadding * 2;\n        const buttonHeight = 30;\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.primary;\n        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.secondaryText;\n        ctx.fillText(\"Reset\", buttonX + boxPadding, buttonY + boxPadding * 2);\n    };\n    const drawPathman = ()=>{\n        drawEntityRelativeToMaze(()=>{\n            const { x, y, mouthAngle, direction } = state.pathman;\n            const { size } = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman;\n            const radius = size / 2;\n            ctx.save();\n            ctx.translate(x, y);\n            switch(direction){\n                case \"right\":\n                    ctx.rotate(0) // No rotation\n                    ;\n                    break;\n                case \"down\":\n                    ctx.rotate(Math.PI / 2) // Rotate 90 degrees clockwise\n                    ;\n                    break;\n                case \"left\":\n                    ctx.rotate(Math.PI) // Rotate 180 degrees\n                    ;\n                    break;\n                case \"up\":\n                    ctx.rotate(-Math.PI / 2) // Rotate 90 degrees counter-clockwise\n                    ;\n                    break;\n            }\n            ctx.beginPath();\n            // Outer circle\n            ctx.arc(0, 0, radius, mouthAngle, Math.PI * 2 - mouthAngle, true);\n            ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.primary;\n            // Mouth\n            ctx.lineTo(-3, 0);\n            const upperLipEndX = radius * Math.cos(Math.PI * 2 - mouthAngle);\n            const upperLipEndY = -radius * Math.sin(Math.PI * 2 - mouthAngle);\n            ctx.moveTo(upperLipEndX, upperLipEndY);\n            ctx.lineTo(0, 0);\n            // Draw it and reset the context\n            ctx.fill();\n            ctx.restore();\n        });\n    };\n    const drawPellets = ()=>{\n        drawEntityRelativeToMaze(()=>{\n            for (const pellet of state.pellets){\n                ctx.beginPath();\n                ctx.arc(pellet.x, pellet.y, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pellets.size, 0, Math.PI * 2, true);\n                ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.primary;\n                ctx.fill();\n            }\n            for (const pellet of state.powerPellets){\n                ctx.beginPath();\n                ctx.arc(pellet.x, pellet.y, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].powerPellets.size, 0, Math.PI * 2, true);\n                ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.primary;\n                ctx.fill();\n            }\n        });\n    };\n    const drawGhosts = ()=>{\n        drawEntityRelativeToMaze(()=>{\n            const size = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.size;\n            const radius = size / 2;\n            const colors = [\n                \"red\",\n                \"blue\",\n                \"pink\",\n                \"orange\"\n            ];\n            state.ghosts.forEach((ghost, index)=>{\n                // REturn index to 0 if it's greater than 3\n                const color = colors[index % colors.length];\n                ctx.fillStyle = color;\n                ctx.beginPath();\n                ctx.arc(ghost.x + 1, ghost.y, radius, Math.PI * -0.5, Math.PI + Math.PI * -0.2, true);\n                ctx.arc(ghost.x - 1, ghost.y, radius, Math.PI * 0.2, Math.PI + Math.PI * 0.5, true);\n                ctx.fillRect(ghost.x - radius + 1, ghost.y - 2, size - 2, size / 2);\n                ctx.fill();\n                ctx.beginPath();\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = \"black\";\n                ctx.fillStyle = \"black\";\n                ctx.moveTo(ghost.x - 6, ghost.y + radius);\n                ctx.lineTo(ghost.x - 4, ghost.y + radius - 6);\n                ctx.lineTo(ghost.x, ghost.y + radius);\n                ctx.lineTo(ghost.x + 4, ghost.y + radius - 6);\n                ctx.lineTo(ghost.x + 6, ghost.y + radius);\n                ctx.stroke();\n                ctx.fill();\n                // add eyes\n                ctx.beginPath();\n                ctx.fillStyle = \"white\";\n                ctx.arc(ghost.x - 4, ghost.y - 3, 3, 0, Math.PI * 2, true);\n                ctx.arc(ghost.x + 4, ghost.y - 3, 3, 0, Math.PI * 2, true);\n                ctx.fill();\n                // add pupils\n                ctx.beginPath();\n                ctx.fillStyle = \"black\";\n                ctx.arc(ghost.x - 4, ghost.y - 3.5, 1.5, 0, Math.PI * 2, true);\n                ctx.arc(ghost.x + 4, ghost.y - 3.5, 1.5, 0, Math.PI * 2, true);\n                ctx.fill();\n            });\n        });\n    };\n    const drawOverlay = ()=>{\n        if (state.phase === \"playing\") return;\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        ctx.font = \"48px Helvetica, Arial, sans-serif\";\n        ctx.fillStyle = \"white\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(state.overlayText, canvas.width / 2, canvas.height / 2);\n    };\n    const drawClickLocation = ()=>{\n        if (state.debug.clickLocation === null) return;\n        const { x, y } = state.debug.clickLocation;\n        ctx.beginPath();\n        ctx.arc(x, y, 4, 0, Math.PI * 2, true);\n        ctx.fillStyle = \"red\";\n        ctx.fill();\n    };\n    const drawCurrentPathmanCell = ()=>{\n        if (state.debug.currentPathmanPosition === null) return;\n        const { x, y } = state.debug.currentPathmanPosition;\n        const cellX = x * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize;\n        const cellY = y * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize;\n        ctx.strokeStyle = \"red\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(cellX, cellY, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n    };\n    const draw = ()=>{\n        ctx.save();\n        ctx.scale(1, 1);\n        // Adapt to the current scale\n        ctx.scale(state.scale, state.scale);\n        drawBackground();\n        drawMaze();\n        if (_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].showRulers) {\n            drawRulers();\n        }\n        drawStats();\n        drawPathman();\n        drawPellets();\n        drawGhosts();\n        drawOverlay();\n        // drawCurrentPathmanCell()\n        // drawClickLocation()\n        ctx.restore();\n    };\n    return {\n        draw,\n        drawCurrentPathmanCell,\n        drawClickLocation,\n        drawOverlay,\n        drawGhosts,\n        drawPellets,\n        drawPathman,\n        drawStats,\n        drawMaze,\n        drawBackground\n    };\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (useDraw);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OlsiaW1wb3J0IHsgR2FtZVN0YXRlLCBDZWxsVHlwZSB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCBjb25maWcgZnJvbSBcIi4vY29uZmlnXCJcblxuY29uc3QgdXNlRHJhdyA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzdGF0ZTogR2FtZVN0YXRlKSA9PiB7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikhXG5cbiAgY29uc3QgYmFja2dyb3VuZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIilcbiAgYmFja2dyb3VuZENhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aFxuICBiYWNrZ3JvdW5kQ2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgY29uc3QgYmFja2dyb3VuZEN0eCA9IGJhY2tncm91bmRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIVxuXG4gIGxldCBtYXplUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuXG4gIGNvbnN0IGRyYXdCYWNrZ3JvdW5kID0gKCkgPT4ge1xuICAgIGJhY2tncm91bmRDdHguZmlsbFN0eWxlID0gY29uZmlnLmNvbG9ycy5iYWNrZ3JvdW5kXG4gICAgY3R4LmZpbGxSZWN0KFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB3aW5kb3cuaW5uZXJXaWR0aCAvIHN0YXRlLnNjYWxlLFxuICAgICAgd2luZG93LmlubmVySGVpZ2h0IC8gc3RhdGUuc2NhbGVcbiAgICApXG4gIH1cblxuICBjb25zdCBjYWxjdWxhdGVNYXplUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgbWF6ZVdpZHRoID0gY29uZmlnLm1hemUuY2VsbHNbMF0ubGVuZ3RoICogY29uZmlnLmNlbGxTaXplXG4gICAgY29uc3QgbWF6ZUhlaWdodCA9IGNvbmZpZy5tYXplLmNlbGxzLmxlbmd0aCAqIGNvbmZpZy5jZWxsU2l6ZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNhbnZhcy53aWR0aCAvIDIsXG4gICAgICB5OiBjYW52YXMuaGVpZ2h0IC8gMiArIG1hemVIZWlnaHQgLyAyLFxuICAgICAgd2lkdGg6IG1hemVXaWR0aCxcbiAgICAgIGhlaWdodDogbWF6ZUhlaWdodCxcbiAgICB9XG4gIH1cblxuICBtYXplUG9zaXRpb24gPSBjYWxjdWxhdGVNYXplUG9zaXRpb24oKVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHtcbiAgICBtYXplUG9zaXRpb24gPSBjYWxjdWxhdGVNYXplUG9zaXRpb24oKVxuICB9KVxuXG4gIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgbWF6ZVBvc2l0aW9uID0gY2FsY3VsYXRlTWF6ZVBvc2l0aW9uKClcbiAgfSlcblxuICBjb25zdCBkcmF3TWF6ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjZWxsU2l6ZSA9IGNvbmZpZy5jZWxsU2l6ZVxuXG4gICAgY29uc3QgY2VsbHMgPSBjb25maWcubWF6ZS5jZWxsc1xuXG4gICAgY3R4LnNhdmUoKVxuICAgIGN0eC50cmFuc2xhdGUobWF6ZVBvc2l0aW9uLngsIG1hemVQb3NpdGlvbi55KVxuXG4gICAgY2VsbHMuZm9yRWFjaCgocm93LCB5KSA9PiB7XG4gICAgICByb3cuZm9yRWFjaCgoY2VsbCwgeCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsWCA9IHggKiBjZWxsU2l6ZVxuICAgICAgICBjb25zdCBjZWxsWSA9IHkgKiBjZWxsU2l6ZVxuXG4gICAgICAgIGlmIChjb25maWcuc2hvd0dyaWQpIHtcbiAgICAgICAgICAvLyBkcmF3IGEgYm94IGFyb3VuZCBlYWNoIGNlbGxcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImdyZWVuXCJcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMVxuICAgICAgICAgIGN0eC5zdHJva2VSZWN0KGNlbGxYLCBjZWxsWSwgY2VsbFNpemUsIGNlbGxTaXplKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlbGwgPT09IENlbGxUeXBlLldhbGxIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5jb2xvcnMud2FsbFxuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGNlbGxYLFxuICAgICAgICAgICAgY2VsbFkgKyAoY2VsbFNpemUgLyAyIC0gY29uZmlnLndhbGxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgY2VsbFNpemUsXG4gICAgICAgICAgICBjb25maWcud2FsbFdpZHRoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlbGwgPT09IENlbGxUeXBlLldhbGxWZXJ0aWNhbCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JzLndhbGxcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBjZWxsWCArIChjZWxsU2l6ZSAvIDIgLSBjb25maWcud2FsbFdpZHRoIC8gMiksXG4gICAgICAgICAgICBjZWxsWSxcbiAgICAgICAgICAgIGNvbmZpZy53YWxsV2lkdGgsXG4gICAgICAgICAgICBjZWxsU2l6ZVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyVG9wTGVmdCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JzLndhbGxcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBjZWxsWCArIChjb25maWcuY2VsbFNpemUgLyAyIC0gY29uZmlnLndhbGxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgY2VsbFkgKyAoY29uZmlnLmNlbGxTaXplIC8gMiAtIGNvbmZpZy53YWxsV2lkdGggLyAyKSxcbiAgICAgICAgICAgIGNvbmZpZy5jZWxsU2l6ZSAvIDIgKyBjb25maWcud2FsbFdpZHRoIC8gMixcbiAgICAgICAgICAgIGNvbmZpZy53YWxsV2lkdGhcbiAgICAgICAgICApXG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgY2VsbFggKyAoY29uZmlnLmNlbGxTaXplIC8gMiAtIGNvbmZpZy53YWxsV2lkdGggLyAyKSxcbiAgICAgICAgICAgIGNlbGxZICsgKGNvbmZpZy5jZWxsU2l6ZSAvIDIgLSBjb25maWcud2FsbFdpZHRoIC8gMiksXG4gICAgICAgICAgICBjb25maWcud2FsbFdpZHRoLFxuICAgICAgICAgICAgY29uZmlnLmNlbGxTaXplIC8gMiArIGNvbmZpZy53YWxsV2lkdGggLyAyXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlbGwgPT09IENlbGxUeXBlLldhbGxDb3JuZXJUb3BSaWdodCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JzLndhbGxcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBjZWxsWCxcbiAgICAgICAgICAgIGNlbGxZICsgKGNvbmZpZy5jZWxsU2l6ZSAvIDIgLSBjb25maWcud2FsbFdpZHRoIC8gMiksXG4gICAgICAgICAgICBjb25maWcuY2VsbFNpemUgLyAyICsgY29uZmlnLndhbGxXaWR0aCAvIDIsXG4gICAgICAgICAgICBjb25maWcud2FsbFdpZHRoXG4gICAgICAgICAgKVxuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGNlbGxYICsgKGNvbmZpZy5jZWxsU2l6ZSAvIDIgLSBjb25maWcud2FsbFdpZHRoIC8gMiksXG4gICAgICAgICAgICBjZWxsWSArIGNvbmZpZy5jZWxsU2l6ZSAvIDIsXG4gICAgICAgICAgICBjb25maWcud2FsbFdpZHRoLFxuICAgICAgICAgICAgY29uZmlnLmNlbGxTaXplIC8gMlxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyQm90dG9tTGVmdCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JzLndhbGxcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBjZWxsWCArIChjb25maWcuY2VsbFNpemUgLyAyIC0gY29uZmlnLndhbGxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgY2VsbFksXG4gICAgICAgICAgICBjb25maWcud2FsbFdpZHRoLFxuICAgICAgICAgICAgY29uZmlnLmNlbGxTaXplIC8gMiArIGNvbmZpZy53YWxsV2lkdGggLyAyXG4gICAgICAgICAgKVxuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGNlbGxYICsgKGNvbmZpZy5jZWxsU2l6ZSAvIDIgLSBjb25maWcud2FsbFdpZHRoIC8gMiksXG4gICAgICAgICAgICBjZWxsWSArIChjb25maWcuY2VsbFNpemUgLyAyIC0gY29uZmlnLndhbGxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgY29uZmlnLmNlbGxTaXplIC8gMiArIGNvbmZpZy53YWxsV2lkdGggLyAyLFxuICAgICAgICAgICAgY29uZmlnLndhbGxXaWR0aFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyQm90dG9tUmlnaHQpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnLmNvbG9ycy53YWxsXG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgY2VsbFgsXG4gICAgICAgICAgICBjZWxsWSArIChjb25maWcuY2VsbFNpemUgLyAyIC0gY29uZmlnLndhbGxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgY29uZmlnLmNlbGxTaXplIC8gMiArIGNvbmZpZy53YWxsV2lkdGggLyAyLFxuICAgICAgICAgICAgY29uZmlnLndhbGxXaWR0aFxuICAgICAgICAgIClcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBjZWxsWCArIChjb25maWcuY2VsbFNpemUgLyAyIC0gY29uZmlnLndhbGxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgY2VsbFksXG4gICAgICAgICAgICBjb25maWcud2FsbFdpZHRoLFxuICAgICAgICAgICAgY29uZmlnLmNlbGxTaXplIC8gMiArIGNvbmZpZy53YWxsV2lkdGggLyAyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cblxuICBjb25zdCBkcmF3UnVsZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBjb25maWcuY2VsbFNpemVcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHgudHJhbnNsYXRlKG1hemVQb3NpdGlvbi54IC0gcGFkZGluZywgbWF6ZVBvc2l0aW9uLnkgLSBwYWRkaW5nKVxuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIlxuICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4Lm1vdmVUbygwLCAwKVxuICAgIGN0eC5saW5lVG8obWF6ZVBvc2l0aW9uLndpZHRoICsgcGFkZGluZyAqIDIsIDApXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgLy8gYWRkIG51bWJlcnMgZm9yIHggY2VsbHMsIDEgYWJvdmUgZWFjaCBjZWxsXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwicmVkXCJcbiAgICBjb25maWcubWF6ZS5jZWxsc1swXS5mb3JFYWNoKChjZWxsLCB4KSA9PiB7XG4gICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgIHgudG9TdHJpbmcoKSxcbiAgICAgICAgY29uZmlnLmNlbGxTaXplICsgeCAqIGNvbmZpZy5jZWxsU2l6ZSArIGNvbmZpZy5jZWxsU2l6ZSAvIDQsXG4gICAgICAgIC1wYWRkaW5nIC8gMlxuICAgICAgKVxuICAgIH0pXG4gICAgY3R4LmZpbGwoKVxuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJncmVlblwiXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4Lm1vdmVUbygwLCAwKVxuICAgIGN0eC5saW5lVG8oMCwgbWF6ZVBvc2l0aW9uLmhlaWdodCArIHBhZGRpbmcgKiAyKVxuICAgIGN0eC5zdHJva2UoKVxuICAgIC8vIGFkZCBudW1iZXJzIGZvciB5IGNlbGxzLCAxIGxlZnQgb2YgZWFjaCBjZWxsXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiZ3JlZW5cIlxuICAgIGNvbmZpZy5tYXplLmNlbGxzLmZvckVhY2goKHJvdywgeSkgPT4ge1xuICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICB5LnRvU3RyaW5nKCksXG4gICAgICAgIC1wYWRkaW5nLFxuICAgICAgICBjb25maWcuY2VsbFNpemUgKyB5ICogY29uZmlnLmNlbGxTaXplICsgY29uZmlnLmNlbGxTaXplIC8gMlxuICAgICAgKVxuICAgIH0pXG4gICAgY3R4LmZpbGwoKVxuXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG5cbiAgY29uc3QgZHJhd0VudGl0eVJlbGF0aXZlVG9NYXplID0gKGRyYXdGdW5jdGlvbjogKCkgPT4gdm9pZCkgPT4ge1xuICAgIGN0eC5zYXZlKClcbiAgICBjdHgudHJhbnNsYXRlKG1hemVQb3NpdGlvbi54LCBtYXplUG9zaXRpb24ueSlcbiAgICBkcmF3RnVuY3Rpb24oKVxuICAgIGN0eC5yZXN0b3JlKClcbiAgfVxuXG4gIGNvbnN0IGRyYXdTdGF0cyA9ICgpID0+IHtcbiAgICBjb25zdCBib3hQYWRkaW5nID0gMTBcblxuICAgIC8vIEJveCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvblxuICAgIGNvbnN0IGJveFdpZHRoID0gY29uZmlnLnNpZGViYXJXaWR0aCAtIGJveFBhZGRpbmdcbiAgICBjb25zdCBib3hIZWlnaHQgPSBjb25maWcuc2lkZWJhcldpZHRoIC0gYm94UGFkZGluZ1xuICAgIGNvbnN0IGJveFggPSBjdHguY2FudmFzLndpZHRoIC0gYm94V2lkdGggLSBib3hQYWRkaW5nXG4gICAgY29uc3QgYm94WSA9IGJveFBhZGRpbmdcblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5jb2xvcnMucHJpbWFyeVxuICAgIGN0eC5saW5lV2lkdGggPSAyXG4gICAgY3R4LnN0cm9rZVJlY3QoYm94WCwgYm94WSwgYm94V2lkdGgsIGJveEhlaWdodClcblxuICAgIGN0eC5mb250ID0gXCIxNnB4IEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWZcIlxuICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JzLnByaW1hcnlcbiAgICBjdHgubGluZVdpZHRoID0gMlxuXG4gICAgY29uc3QgdGV4dFggPSBib3hYICsgYm94UGFkZGluZ1xuICAgIGNvbnN0IHRleHRZID0gYm94WSArIChib3hIZWlnaHQgLSA1MCkgLyAyXG5cbiAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCJcbiAgICBjdHguZmlsbFRleHQoYEZQUzogJHtzdGF0ZS5jdXJyZW50RlBTLnRvRml4ZWQoMCl9YCwgdGV4dFgsIHRleHRZKVxuICAgIGN0eC5maWxsVGV4dChcbiAgICAgIGBQZWxsZXRzOiAke3N0YXRlLnBlbGxldHMubGVuZ3RofWAsXG4gICAgICB0ZXh0WCxcbiAgICAgIHRleHRZICsgYm94UGFkZGluZyAqIDJcbiAgICApXG5cbiAgICAvLyBBZGQgcmVzZXQgYnV0dG9uXG4gICAgY29uc3QgYnV0dG9uWCA9IGJveFggKyBib3hQYWRkaW5nXG4gICAgY29uc3QgYnV0dG9uWSA9IHRleHRZICsgKGJveFBhZGRpbmcgKiAyICsgMjApXG4gICAgY29uc3QgYnV0dG9uV2lkdGggPSBib3hXaWR0aCAtIGJveFBhZGRpbmcgKiAyXG4gICAgY29uc3QgYnV0dG9uSGVpZ2h0ID0gMzBcbiAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnLmNvbG9ycy5wcmltYXJ5XG4gICAgY3R4LmZpbGxSZWN0KGJ1dHRvblgsIGJ1dHRvblksIGJ1dHRvbldpZHRoLCBidXR0b25IZWlnaHQpXG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5jb2xvcnMuc2Vjb25kYXJ5VGV4dFxuXG4gICAgY3R4LmZpbGxUZXh0KFwiUmVzZXRcIiwgYnV0dG9uWCArIGJveFBhZGRpbmcsIGJ1dHRvblkgKyBib3hQYWRkaW5nICogMilcbiAgfVxuXG4gIGNvbnN0IGRyYXdQYXRobWFuID0gKCkgPT4ge1xuICAgIGRyYXdFbnRpdHlSZWxhdGl2ZVRvTWF6ZSgoKSA9PiB7XG4gICAgICBjb25zdCB7IHgsIHksIG1vdXRoQW5nbGUsIGRpcmVjdGlvbiB9ID0gc3RhdGUucGF0aG1hblxuICAgICAgY29uc3QgeyBzaXplIH0gPSBjb25maWcucGF0aG1hblxuXG4gICAgICBjb25zdCByYWRpdXMgPSBzaXplIC8gMlxuXG4gICAgICBjdHguc2F2ZSgpXG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpXG5cbiAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIGN0eC5yb3RhdGUoMCkgLy8gTm8gcm90YXRpb25cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAvIDIpIC8vIFJvdGF0ZSA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKSAvLyBSb3RhdGUgMTgwIGRlZ3JlZXNcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICBjdHgucm90YXRlKC1NYXRoLlBJIC8gMikgLy8gUm90YXRlIDkwIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKClcblxuICAgICAgLy8gT3V0ZXIgY2lyY2xlXG4gICAgICBjdHguYXJjKDAsIDAsIHJhZGl1cywgbW91dGhBbmdsZSwgTWF0aC5QSSAqIDIgLSBtb3V0aEFuZ2xlLCB0cnVlKVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5jb2xvcnMucHJpbWFyeVxuXG4gICAgICAvLyBNb3V0aFxuICAgICAgY3R4LmxpbmVUbygtMywgMClcblxuICAgICAgY29uc3QgdXBwZXJMaXBFbmRYID0gcmFkaXVzICogTWF0aC5jb3MoTWF0aC5QSSAqIDIgLSBtb3V0aEFuZ2xlKVxuICAgICAgY29uc3QgdXBwZXJMaXBFbmRZID0gLXJhZGl1cyAqIE1hdGguc2luKE1hdGguUEkgKiAyIC0gbW91dGhBbmdsZSlcblxuICAgICAgY3R4Lm1vdmVUbyh1cHBlckxpcEVuZFgsIHVwcGVyTGlwRW5kWSlcbiAgICAgIGN0eC5saW5lVG8oMCwgMClcblxuICAgICAgLy8gRHJhdyBpdCBhbmQgcmVzZXQgdGhlIGNvbnRleHRcbiAgICAgIGN0eC5maWxsKClcbiAgICAgIGN0eC5yZXN0b3JlKClcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgZHJhd1BlbGxldHMgPSAoKSA9PiB7XG4gICAgZHJhd0VudGl0eVJlbGF0aXZlVG9NYXplKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcGVsbGV0IG9mIHN0YXRlLnBlbGxldHMpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5hcmMocGVsbGV0LngsIHBlbGxldC55LCBjb25maWcucGVsbGV0cy5zaXplLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSlcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5jb2xvcnMucHJpbWFyeVxuICAgICAgICBjdHguZmlsbCgpXG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgcGVsbGV0IG9mIHN0YXRlLnBvd2VyUGVsbGV0cykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICBwZWxsZXQueCxcbiAgICAgICAgICBwZWxsZXQueSxcbiAgICAgICAgICBjb25maWcucG93ZXJQZWxsZXRzLnNpemUsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5jb2xvcnMucHJpbWFyeVxuICAgICAgICBjdHguZmlsbCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGRyYXdHaG9zdHMgPSAoKSA9PiB7XG4gICAgZHJhd0VudGl0eVJlbGF0aXZlVG9NYXplKCgpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSBjb25maWcuZ2hvc3RzLnNpemVcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHNpemUgLyAyXG5cbiAgICAgIGNvbnN0IGNvbG9ycyA9IFtcInJlZFwiLCBcImJsdWVcIiwgXCJwaW5rXCIsIFwib3JhbmdlXCJdXG5cbiAgICAgIHN0YXRlLmdob3N0cy5mb3JFYWNoKChnaG9zdCwgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gUkV0dXJuIGluZGV4IHRvIDAgaWYgaXQncyBncmVhdGVyIHRoYW4gM1xuICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yc1tpbmRleCAlIGNvbG9ycy5sZW5ndGhdXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguYXJjKFxuICAgICAgICAgIGdob3N0LnggKyAxLFxuICAgICAgICAgIGdob3N0LnksXG4gICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgIE1hdGguUEkgKiAtMC41LFxuICAgICAgICAgIE1hdGguUEkgKyBNYXRoLlBJICogLTAuMixcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcblxuICAgICAgICBjdHguYXJjKFxuICAgICAgICAgIGdob3N0LnggLSAxLFxuICAgICAgICAgIGdob3N0LnksXG4gICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgIE1hdGguUEkgKiAwLjIsXG4gICAgICAgICAgTWF0aC5QSSArIE1hdGguUEkgKiAwLjUsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG5cbiAgICAgICAgY3R4LmZpbGxSZWN0KGdob3N0LnggLSByYWRpdXMgKyAxLCBnaG9zdC55IC0gMiwgc2l6ZSAtIDIsIHNpemUgLyAyKVxuICAgICAgICBjdHguZmlsbCgpXG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIlxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiXG4gICAgICAgIGN0eC5tb3ZlVG8oZ2hvc3QueCAtIDYsIGdob3N0LnkgKyByYWRpdXMpXG4gICAgICAgIGN0eC5saW5lVG8oZ2hvc3QueCAtIDQsIGdob3N0LnkgKyByYWRpdXMgLSA2KVxuICAgICAgICBjdHgubGluZVRvKGdob3N0LngsIGdob3N0LnkgKyByYWRpdXMpXG4gICAgICAgIGN0eC5saW5lVG8oZ2hvc3QueCArIDQsIGdob3N0LnkgKyByYWRpdXMgLSA2KVxuICAgICAgICBjdHgubGluZVRvKGdob3N0LnggKyA2LCBnaG9zdC55ICsgcmFkaXVzKVxuICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgY3R4LmZpbGwoKVxuXG4gICAgICAgIC8vIGFkZCBleWVzXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgIGN0eC5hcmMoZ2hvc3QueCAtIDQsIGdob3N0LnkgLSAzLCAzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSlcbiAgICAgICAgY3R4LmFyYyhnaG9zdC54ICsgNCwgZ2hvc3QueSAtIDMsIDMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKVxuICAgICAgICBjdHguZmlsbCgpXG5cbiAgICAgICAgLy8gYWRkIHB1cGlsc1xuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIlxuICAgICAgICBjdHguYXJjKGdob3N0LnggLSA0LCBnaG9zdC55IC0gMy41LCAxLjUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKVxuICAgICAgICBjdHguYXJjKGdob3N0LnggKyA0LCBnaG9zdC55IC0gMy41LCAxLjUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKVxuICAgICAgICBjdHguZmlsbCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBkcmF3T3ZlcmxheSA9ICgpID0+IHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09IFwicGxheWluZ1wiKSByZXR1cm5cblxuICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGN0eC5mb250ID0gXCI0OHB4IEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWZcIlxuICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCJcblxuICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiXG4gICAgY3R4LmZpbGxUZXh0KHN0YXRlLm92ZXJsYXlUZXh0LCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMilcbiAgfVxuXG4gIGNvbnN0IGRyYXdDbGlja0xvY2F0aW9uID0gKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5kZWJ1Zy5jbGlja0xvY2F0aW9uID09PSBudWxsKSByZXR1cm5cblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gc3RhdGUuZGVidWcuY2xpY2tMb2NhdGlvblxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5hcmMoeCwgeSwgNCwgMCwgTWF0aC5QSSAqIDIsIHRydWUpXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwicmVkXCJcbiAgICBjdHguZmlsbCgpXG4gIH1cblxuICBjb25zdCBkcmF3Q3VycmVudFBhdGhtYW5DZWxsID0gKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5kZWJ1Zy5jdXJyZW50UGF0aG1hblBvc2l0aW9uID09PSBudWxsKSByZXR1cm5cblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gc3RhdGUuZGVidWcuY3VycmVudFBhdGhtYW5Qb3NpdGlvblxuICAgIGNvbnN0IGNlbGxYID0geCAqIGNvbmZpZy5jZWxsU2l6ZVxuICAgIGNvbnN0IGNlbGxZID0geSAqIGNvbmZpZy5jZWxsU2l6ZVxuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIlxuICAgIGN0eC5saW5lV2lkdGggPSAyXG4gICAgY3R4LnN0cm9rZVJlY3QoY2VsbFgsIGNlbGxZLCBjb25maWcuY2VsbFNpemUsIGNvbmZpZy5jZWxsU2l6ZSlcbiAgfVxuXG4gIGNvbnN0IGRyYXcgPSAoKSA9PiB7XG4gICAgY3R4LnNhdmUoKVxuXG4gICAgY3R4LnNjYWxlKDEsIDEpXG5cbiAgICAvLyBBZGFwdCB0byB0aGUgY3VycmVudCBzY2FsZVxuICAgIGN0eC5zY2FsZShzdGF0ZS5zY2FsZSwgc3RhdGUuc2NhbGUpXG5cbiAgICBkcmF3QmFja2dyb3VuZCgpXG4gICAgZHJhd01hemUoKVxuICAgIGlmIChjb25maWcuc2hvd1J1bGVycykge1xuICAgICAgZHJhd1J1bGVycygpXG4gICAgfVxuICAgIGRyYXdTdGF0cygpXG4gICAgZHJhd1BhdGhtYW4oKVxuICAgIGRyYXdQZWxsZXRzKClcbiAgICBkcmF3R2hvc3RzKClcbiAgICBkcmF3T3ZlcmxheSgpXG4gICAgLy8gZHJhd0N1cnJlbnRQYXRobWFuQ2VsbCgpXG4gICAgLy8gZHJhd0NsaWNrTG9jYXRpb24oKVxuXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkcmF3LFxuICAgIGRyYXdDdXJyZW50UGF0aG1hbkNlbGwsXG4gICAgZHJhd0NsaWNrTG9jYXRpb24sXG4gICAgZHJhd092ZXJsYXksXG4gICAgZHJhd0dob3N0cyxcbiAgICBkcmF3UGVsbGV0cyxcbiAgICBkcmF3UGF0aG1hbixcbiAgICBkcmF3U3RhdHMsXG4gICAgZHJhd01hemUsXG4gICAgZHJhd0JhY2tncm91bmQsXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgdXNlRHJhd1xuIl0sIm5hbWVzIjpbIkNlbGxUeXBlIiwiY29uZmlnIiwidXNlRHJhdyIsImNhbnZhcyIsInN0YXRlIiwiY3R4IiwiZ2V0Q29udGV4dCIsImJhY2tncm91bmRDYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsImJhY2tncm91bmRDdHgiLCJtYXplUG9zaXRpb24iLCJ4IiwieSIsImRyYXdCYWNrZ3JvdW5kIiwiZmlsbFN0eWxlIiwiY29sb3JzIiwiYmFja2dyb3VuZCIsImZpbGxSZWN0Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsInNjYWxlIiwiaW5uZXJIZWlnaHQiLCJjYWxjdWxhdGVNYXplUG9zaXRpb24iLCJtYXplV2lkdGgiLCJtYXplIiwiY2VsbHMiLCJsZW5ndGgiLCJjZWxsU2l6ZSIsIm1hemVIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwiZHJhd01hemUiLCJzYXZlIiwidHJhbnNsYXRlIiwiZm9yRWFjaCIsInJvdyIsImNlbGwiLCJjZWxsWCIsImNlbGxZIiwic2hvd0dyaWQiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZVJlY3QiLCJXYWxsSG9yaXpvbnRhbCIsIndhbGwiLCJ3YWxsV2lkdGgiLCJXYWxsVmVydGljYWwiLCJXYWxsQ29ybmVyVG9wTGVmdCIsIldhbGxDb3JuZXJUb3BSaWdodCIsIldhbGxDb3JuZXJCb3R0b21MZWZ0IiwiV2FsbENvcm5lckJvdHRvbVJpZ2h0IiwicmVzdG9yZSIsImRyYXdSdWxlcnMiLCJwYWRkaW5nIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbFRleHQiLCJ0b1N0cmluZyIsImZpbGwiLCJkcmF3RW50aXR5UmVsYXRpdmVUb01hemUiLCJkcmF3RnVuY3Rpb24iLCJkcmF3U3RhdHMiLCJib3hQYWRkaW5nIiwiYm94V2lkdGgiLCJzaWRlYmFyV2lkdGgiLCJib3hIZWlnaHQiLCJib3hYIiwiYm94WSIsInByaW1hcnkiLCJmb250IiwidGV4dFgiLCJ0ZXh0WSIsInRleHRBbGlnbiIsImN1cnJlbnRGUFMiLCJ0b0ZpeGVkIiwicGVsbGV0cyIsImJ1dHRvblgiLCJidXR0b25ZIiwiYnV0dG9uV2lkdGgiLCJidXR0b25IZWlnaHQiLCJzZWNvbmRhcnlUZXh0IiwiZHJhd1BhdGhtYW4iLCJtb3V0aEFuZ2xlIiwiZGlyZWN0aW9uIiwicGF0aG1hbiIsInNpemUiLCJyYWRpdXMiLCJyb3RhdGUiLCJNYXRoIiwiUEkiLCJhcmMiLCJ1cHBlckxpcEVuZFgiLCJjb3MiLCJ1cHBlckxpcEVuZFkiLCJzaW4iLCJkcmF3UGVsbGV0cyIsInBlbGxldCIsInBvd2VyUGVsbGV0cyIsImRyYXdHaG9zdHMiLCJnaG9zdHMiLCJnaG9zdCIsImluZGV4IiwiY29sb3IiLCJkcmF3T3ZlcmxheSIsInBoYXNlIiwib3ZlcmxheVRleHQiLCJkcmF3Q2xpY2tMb2NhdGlvbiIsImRlYnVnIiwiY2xpY2tMb2NhdGlvbiIsImRyYXdDdXJyZW50UGF0aG1hbkNlbGwiLCJjdXJyZW50UGF0aG1hblBvc2l0aW9uIiwiZHJhdyIsInNob3dSdWxlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pathman/draw.ts\n"));

/***/ }),

/***/ "./pathman/entities.ts":
/*!*****************************!*\
  !*** ./pathman/entities.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGhosts: function() { return /* binding */ createGhosts; },\n/* harmony export */   createPathman: function() { return /* binding */ createPathman; },\n/* harmony export */   createPellets: function() { return /* binding */ createPellets; },\n/* harmony export */   createPowerPellets: function() { return /* binding */ createPowerPellets; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./pathman/config.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./pathman/types.ts\");\n\n\nconst createEntities = function(type) {\n    let attributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const entities = [];\n    _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].maze.cells.forEach((row, y)=>{\n        row.forEach((cell, x)=>{\n            if (cell === type) {\n                const entityX = x * _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellSize / 2;\n                const entityY = y * _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellSize / 2;\n                const currentCell = {\n                    x,\n                    y\n                };\n                entities.push({\n                    x: entityX,\n                    y: entityY,\n                    currentCell,\n                    ...attributes\n                });\n            }\n        });\n    });\n    return entities;\n};\nconst createPellets = ()=>createEntities(_types__WEBPACK_IMPORTED_MODULE_1__.CellType.Pellet);\nconst createPowerPellets = ()=>createEntities(_types__WEBPACK_IMPORTED_MODULE_1__.CellType.PowerPellet);\nconst createGhosts = ()=>{\n    const attributes = {\n        direction: \"none\",\n        isMoving: false\n    };\n    return createEntities(_types__WEBPACK_IMPORTED_MODULE_1__.CellType.Ghost, attributes).map((entity, index)=>{\n        return {\n            id: \"ghost-\".concat(index),\n            ...entity,\n            path: []\n        };\n    });\n};\nconst createPathman = ()=>{\n    const entity = createEntities(_types__WEBPACK_IMPORTED_MODULE_1__.CellType.Pathman, {\n        direction: \"none\",\n        isMoving: false\n    })[0];\n    return {\n        ...entity,\n        mouthOpening: false,\n        mouthAngle: 0\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL2VudGl0aWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2QjtBQUMrQztBQUU1RSxNQUFNRSxpQkFBaUIsU0FDckJDO1FBQ0FDLDhFQUE4QixDQUFDO0lBRS9CLE1BQU1DLFdBQXFCLEVBQUU7SUFFN0JMLG9EQUFXLENBQUNPLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLEtBQUtDO1FBQzlCRCxJQUFJRCxPQUFPLENBQUMsQ0FBQ0csTUFBTUM7WUFDakIsSUFBSUQsU0FBU1IsTUFBTTtnQkFDakIsTUFBTVUsVUFBVUQsSUFBSVosd0RBQWUsR0FBR0Esd0RBQWUsR0FBRztnQkFDeEQsTUFBTWUsVUFBVUwsSUFBSVYsd0RBQWUsR0FBR0Esd0RBQWUsR0FBRztnQkFDeEQsTUFBTWdCLGNBQWM7b0JBQUVKO29CQUFHRjtnQkFBRTtnQkFDM0JMLFNBQVNZLElBQUksQ0FBQztvQkFBRUwsR0FBR0M7b0JBQVNILEdBQUdLO29CQUFTQztvQkFBYSxHQUFHWixVQUFVO2dCQUFDO1lBQ3JFO1FBQ0Y7SUFDRjtJQUVBLE9BQU9DO0FBQ1Q7QUFFTyxNQUFNYSxnQkFBZ0IsSUFBZ0JoQixlQUFlRCw0Q0FBUUEsQ0FBQ2tCLE1BQU0sRUFBQztBQUNyRSxNQUFNQyxxQkFBcUIsSUFDaENsQixlQUFlRCw0Q0FBUUEsQ0FBQ29CLFdBQVcsRUFBQztBQUMvQixNQUFNQyxlQUFlO0lBQzFCLE1BQU1sQixhQUE4QjtRQUFFbUIsV0FBVztRQUFRQyxVQUFVO0lBQU07SUFDekUsT0FBT3RCLGVBQWVELDRDQUFRQSxDQUFDd0IsS0FBSyxFQUFFckIsWUFBWXNCLEdBQUcsQ0FBQyxDQUFDQyxRQUFRQztRQUM3RCxPQUFPO1lBQ0xDLElBQUksU0FBZSxPQUFORDtZQUNiLEdBQUdELE1BQU07WUFDVEcsTUFBTSxFQUFFO1FBQ1Y7SUFDRjtBQUNGLEVBQUM7QUFDTSxNQUFNQyxnQkFBZ0I7SUFDM0IsTUFBTUosU0FBU3pCLGVBQWVELDRDQUFRQSxDQUFDK0IsT0FBTyxFQUFFO1FBQzlDVCxXQUFXO1FBQ1hDLFVBQVU7SUFDWixFQUFFLENBQUMsRUFBRTtJQUVMLE9BQU87UUFDTCxHQUFHRyxNQUFNO1FBQ1RNLGNBQWM7UUFDZEMsWUFBWTtJQUNkO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYXRobWFuL2VudGl0aWVzLnRzPzczYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbmZpZyBmcm9tIFwiLi9jb25maWdcIlxuaW1wb3J0IHsgQ2VsbFR5cGUsIEVudGl0eSwgUGF0aG1hbkVudGl0eSwgR2hvc3RFbnRpdHksIENlbGwgfSBmcm9tIFwiLi90eXBlc1wiXG5cbmNvbnN0IGNyZWF0ZUVudGl0aWVzID0gKFxuICB0eXBlOiBDZWxsVHlwZSxcbiAgYXR0cmlidXRlczogUGFydGlhbDxFbnRpdHk+ID0ge31cbik6IEVudGl0eVtdID0+IHtcbiAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW11cblxuICBjb25maWcubWF6ZS5jZWxscy5mb3JFYWNoKChyb3csIHkpID0+IHtcbiAgICByb3cuZm9yRWFjaCgoY2VsbCwgeCkgPT4ge1xuICAgICAgaWYgKGNlbGwgPT09IHR5cGUpIHtcbiAgICAgICAgY29uc3QgZW50aXR5WCA9IHggKiBjb25maWcuY2VsbFNpemUgKyBjb25maWcuY2VsbFNpemUgLyAyXG4gICAgICAgIGNvbnN0IGVudGl0eVkgPSB5ICogY29uZmlnLmNlbGxTaXplICsgY29uZmlnLmNlbGxTaXplIC8gMlxuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IHsgeCwgeSB9XG4gICAgICAgIGVudGl0aWVzLnB1c2goeyB4OiBlbnRpdHlYLCB5OiBlbnRpdHlZLCBjdXJyZW50Q2VsbCwgLi4uYXR0cmlidXRlcyB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIGVudGl0aWVzXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQZWxsZXRzID0gKCk6IEVudGl0eVtdID0+IGNyZWF0ZUVudGl0aWVzKENlbGxUeXBlLlBlbGxldClcbmV4cG9ydCBjb25zdCBjcmVhdGVQb3dlclBlbGxldHMgPSAoKTogRW50aXR5W10gPT5cbiAgY3JlYXRlRW50aXRpZXMoQ2VsbFR5cGUuUG93ZXJQZWxsZXQpXG5leHBvcnQgY29uc3QgY3JlYXRlR2hvc3RzID0gKCk6IEdob3N0RW50aXR5W10gPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzOiBQYXJ0aWFsPEVudGl0eT4gPSB7IGRpcmVjdGlvbjogXCJub25lXCIsIGlzTW92aW5nOiBmYWxzZSB9XG4gIHJldHVybiBjcmVhdGVFbnRpdGllcyhDZWxsVHlwZS5HaG9zdCwgYXR0cmlidXRlcykubWFwKChlbnRpdHksIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgZ2hvc3QtJHtpbmRleH1gLFxuICAgICAgLi4uZW50aXR5LFxuICAgICAgcGF0aDogW10sXG4gICAgfVxuICB9KVxufVxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhdGhtYW4gPSAoKTogUGF0aG1hbkVudGl0eSA9PiB7XG4gIGNvbnN0IGVudGl0eSA9IGNyZWF0ZUVudGl0aWVzKENlbGxUeXBlLlBhdGhtYW4sIHtcbiAgICBkaXJlY3Rpb246IFwibm9uZVwiLFxuICAgIGlzTW92aW5nOiBmYWxzZSxcbiAgfSlbMF1cblxuICByZXR1cm4ge1xuICAgIC4uLmVudGl0eSxcbiAgICBtb3V0aE9wZW5pbmc6IGZhbHNlLFxuICAgIG1vdXRoQW5nbGU6IDAsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjb25maWciLCJDZWxsVHlwZSIsImNyZWF0ZUVudGl0aWVzIiwidHlwZSIsImF0dHJpYnV0ZXMiLCJlbnRpdGllcyIsIm1hemUiLCJjZWxscyIsImZvckVhY2giLCJyb3ciLCJ5IiwiY2VsbCIsIngiLCJlbnRpdHlYIiwiY2VsbFNpemUiLCJlbnRpdHlZIiwiY3VycmVudENlbGwiLCJwdXNoIiwiY3JlYXRlUGVsbGV0cyIsIlBlbGxldCIsImNyZWF0ZVBvd2VyUGVsbGV0cyIsIlBvd2VyUGVsbGV0IiwiY3JlYXRlR2hvc3RzIiwiZGlyZWN0aW9uIiwiaXNNb3ZpbmciLCJHaG9zdCIsIm1hcCIsImVudGl0eSIsImluZGV4IiwiaWQiLCJwYXRoIiwiY3JlYXRlUGF0aG1hbiIsIlBhdGhtYW4iLCJtb3V0aE9wZW5pbmciLCJtb3V0aEFuZ2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pathman/entities.ts\n"));

/***/ }),

/***/ "./pathman/game.ts":
/*!*************************!*\
  !*** ./pathman/game.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./pathman/types.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./pathman/config.ts\");\n/* harmony import */ var _maze__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maze */ \"./pathman/maze.ts\");\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state */ \"./pathman/state.ts\");\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw */ \"./pathman/draw.ts\");\n/* harmony import */ var _pathfinding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pathfinding */ \"./pathman/pathfinding.ts\");\n\n\n\n\n\n\nconst game = (canvas)=>{\n    let state = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getInitialState)();\n    const { draw, drawOverlay } = (0,_draw__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(canvas, state);\n    const init = ()=>{\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        calculateScale();\n    };\n    const calculateScale = ()=>{\n        // TODO: calculate width based on the number of cells in the maze\n        // const mazeWidth = 0 + config.sidebarWidth\n        const scale = window.innerWidth / window.innerWidth;\n        state.scale = scale;\n    };\n    const updatePathman = ()=>{\n        // First, find the cell that pathman is in currently\n        const cellX = Math.floor(state.pathman.x / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n        const cellY = Math.floor(state.pathman.y / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n        state.pathman.currentCell = {\n            x: cellX,\n            y: cellY\n        };\n        // Animate mouth\n        if (state.pathman.isMoving) {\n            const mouthSpeed = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.mouthSpeed // Speed of mouth opening/closing\n            ;\n            const maxLowestAngle = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.maxLowestAngle // Maximum mouth angle in radians\n            ;\n            if (state.pathman.mouthOpening) {\n                state.pathman.mouthAngle -= mouthSpeed // Increase the mouth angle\n                ;\n                if (state.pathman.mouthAngle < maxLowestAngle) {\n                    state.pathman.mouthAngle = maxLowestAngle // Limit the mouth angle\n                    ;\n                    state.pathman.mouthOpening = false // Start closing the mouth\n                    ;\n                }\n            } else {\n                state.pathman.mouthAngle += mouthSpeed // Decrease the mouth angle\n                ;\n                if (state.pathman.mouthAngle > 0) {\n                    state.pathman.mouthAngle = 0;\n                    state.pathman.mouthOpening = true // Start opening the mouth\n                    ;\n                }\n            }\n        }\n        // Move\n        if (state.pathman.direction === \"none\" || !state.pathman.isMoving) return;\n        let newX = state.pathman.x;\n        let newY = state.pathman.y;\n        if (state.pathman.direction === \"right\") {\n            newX += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        if (state.pathman.direction === \"left\") {\n            newX -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        if (state.pathman.direction === \"up\") {\n            newY -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        if (state.pathman.direction === \"down\") {\n            newY += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.speed;\n        }\n        const pathmanRadius = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.size / 2;\n        // Check for collisions\n        const maze = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells;\n        const currentCell = {\n            x: cellX,\n            y: cellY\n        };\n        state.debug.currentPathmanPosition = {\n            x: state.pathman.x,\n            y: state.pathman.y,\n            currentCell\n        };\n        const direction = state.pathman.direction;\n        let adjacentCell;\n        let willColide = false;\n        if (direction === \"right\" && state.pathman.x >= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - pathmanRadius) {\n            var _maze_cellY;\n            adjacentCell = (_maze_cellY = maze[cellY]) === null || _maze_cellY === void 0 ? void 0 : _maze_cellY[cellX + 1];\n        }\n        if (direction === \"left\" && state.pathman.x <= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + pathmanRadius) {\n            var _maze_cellY1;\n            adjacentCell = (_maze_cellY1 = maze[cellY]) === null || _maze_cellY1 === void 0 ? void 0 : _maze_cellY1[cellX - 1];\n        }\n        if (direction === \"up\" && state.pathman.y <= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + pathmanRadius) {\n            var _maze_;\n            adjacentCell = (_maze_ = maze[cellY - 1]) === null || _maze_ === void 0 ? void 0 : _maze_[cellX];\n        }\n        if (direction === \"down\" && state.pathman.y >= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - pathmanRadius) {\n            var _maze_1;\n            adjacentCell = (_maze_1 = maze[cellY + 1]) === null || _maze_1 === void 0 ? void 0 : _maze_1[cellX];\n        }\n        // Check for collisions with walls\n        if (adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallHorizontal || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallVertical || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopLeft || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopRight || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomLeft || adjacentCell === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomRight) {\n            willColide = true;\n        }\n        // Check for collisions with canvas\n        // if (newX - pathmanRadius < 0 || newX + pathmanRadius > canvas.width) {\n        //   willColide = true\n        // }\n        // if (newY - pathmanRadius < 0 || newY + pathmanRadius > canvas.height) {\n        //   willColide = true\n        // }\n        if (willColide) {\n            state.pathman.isMoving = false;\n            return;\n        }\n        // Allow wrapping around the maze\n        const { x: mazeWidth, y: mazeHeight } = (0,_maze__WEBPACK_IMPORTED_MODULE_2__.calculateMazeDimensions)();\n        // If going right, should wrap to the same x position on the left side of the maze\n        if (direction === \"right\" && newX + pathmanRadius > mazeWidth) {\n            newX = 0 + pathmanRadius;\n        }\n        // If going left, should wrap to the same x position on the right side of the maze\n        if (direction === \"left\" && newX - pathmanRadius < 0) {\n            newX = mazeWidth - pathmanRadius;\n        }\n        // If going up, should wrap to the same y position on the bottom side of the maze\n        if (direction === \"up\" && newY - pathmanRadius < 0) {\n            newY = mazeHeight - pathmanRadius;\n        }\n        // If going down, should wrap to the same y position on the top side of the maze\n        if (direction === \"down\" && newY + pathmanRadius > mazeHeight) {\n            newY = 0 + pathmanRadius;\n        }\n        state.pathman.x = newX;\n        state.pathman.y = newY;\n        state.pathman.currentCell = {\n            x: Math.floor(newX / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize),\n            y: Math.floor(newY / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize)\n        };\n    };\n    const updateGhosts = ()=>{\n        const ghosts = state.ghosts;\n        if (!state.pathman.currentCell) return;\n        ghosts.forEach((ghost, index)=>{\n            var _state_pathman_currentCell, _state_pathman_currentCell1, _ghost_path;\n            // First, find the cell that ghost is in currently\n            const cellX = Math.floor(ghost.x / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n            const cellY = Math.floor(ghost.y / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize);\n            const currentCell = {\n                x: cellX,\n                y: cellY\n            };\n            ghost.currentCell = currentCell;\n            if (ghost.path.length === 0) {\n                ghost.path = (0,_pathfinding__WEBPACK_IMPORTED_MODULE_5__.aStar)({\n                    x: ghost.currentCell.x,\n                    y: ghost.currentCell.y\n                }, {\n                    x: state.pathman.currentCell.x || 1,\n                    y: state.pathman.currentCell.y || 1\n                }, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells);\n            }\n            // Move\n            const ghostRadius = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.size / 2;\n            const maze = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells;\n            let newX = ghost.x;\n            let newY = ghost.y;\n            // Advance towards the next step in the path\n            const calculateDirection = (entity, nextStep)=>{\n                // check for same cell\n                if (nextStep.x === entity.currentCell.x && nextStep.y === entity.currentCell.y) {\n                    return entity.direction;\n                }\n                // Calculate the center position of the next cell in absolute canvas coordinates\n                const nextCellCenterX = nextStep.x * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2;\n                const nextCellCenterY = nextStep.y * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize / 2;\n                // Calculate the difference in cell coordinates between the entity's current cell and the next step\n                const cellDeltaX = nextStep.x - entity.currentCell.x;\n                const cellDeltaY = nextStep.y - entity.currentCell.y;\n                // Determine the primary axis of movement based on the larger delta\n                const primaryAxis = Math.abs(cellDeltaX) > Math.abs(cellDeltaY) ? \"x\" : \"y\";\n                // Initialize the direction as \"none\"\n                let direction = \"none\";\n                // Determine the direction based on the primary axis and the sign of the delta\n                if (primaryAxis === \"x\") {\n                    direction = cellDeltaX > 0 ? \"right\" : \"left\";\n                } else {\n                    direction = cellDeltaY > 0 ? \"down\" : \"up\";\n                }\n                if (entity.direction === \"none\") {\n                    return direction;\n                }\n                // Check if the entity has reached the center of the next cell along the primary axis of movement\n                // If not, continue in the current direction\n                if (entity.direction === \"right\" && entity.x < nextCellCenterX) return entity.direction;\n                if (entity.direction === \"left\" && entity.x > nextCellCenterX) return entity.direction;\n                if (entity.direction === \"up\" && entity.y > nextCellCenterY) return entity.direction;\n                if (entity.direction === \"down\" && entity.y < nextCellCenterY) return entity.direction;\n                // Return the new direction if the entity has reached the center of the next cell\n                return direction;\n            };\n            if (ghost.path.length > 0) {\n                if (ghost.path[0].x === ghost.currentCell.x && ghost.path[0].y === ghost.currentCell.y) {\n                    ghost.path.shift();\n                }\n                const nextStep = ghost.path[0]// Get the next step in the path\n                ;\n                // console.log(`ghost ${index} next step`, nextStep.x, nextStep.y, ghost.direction)\n                if (!nextStep) return;\n                ghost.direction = calculateDirection(ghost, nextStep) // Calculate the new direction based on the next step\n                ;\n            // console.log(`ghost ${index} new direction`, ghost.direction)\n            }\n            // Move\n            if (ghost.direction === \"right\") {\n                newX += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            if (ghost.direction === \"left\") {\n                newX -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            if (ghost.direction === \"up\") {\n                newY -= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            if (ghost.direction === \"down\") {\n                newY += _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ghosts.speed;\n            }\n            // Check for collisions\n            const direction = ghost.direction;\n            let adjacentCellType;\n            let adjacentCell;\n            let willColide = false;\n            if (direction === \"right\" && ghost.x >= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - ghostRadius) {\n                var _maze_cellY;\n                adjacentCellType = (_maze_cellY = maze[cellY]) === null || _maze_cellY === void 0 ? void 0 : _maze_cellY[cellX + 1];\n                adjacentCell = {\n                    x: cellX + 1,\n                    y: cellY\n                };\n            }\n            if (direction === \"left\" && ghost.x <= cellX * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + ghostRadius) {\n                var _maze_cellY1;\n                adjacentCellType = (_maze_cellY1 = maze[cellY]) === null || _maze_cellY1 === void 0 ? void 0 : _maze_cellY1[cellX - 1];\n                adjacentCell = {\n                    x: cellX - 1,\n                    y: cellY\n                };\n            }\n            if (direction === \"up\" && ghost.y <= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + ghostRadius) {\n                var _maze_;\n                adjacentCellType = (_maze_ = maze[cellY - 1]) === null || _maze_ === void 0 ? void 0 : _maze_[cellX];\n                adjacentCell = {\n                    x: cellX,\n                    y: cellY - 1\n                };\n            }\n            if (direction === \"down\" && ghost.y >= cellY * _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize - ghostRadius) {\n                var _maze_1;\n                adjacentCellType = (_maze_1 = maze[cellY + 1]) === null || _maze_1 === void 0 ? void 0 : _maze_1[cellX];\n                adjacentCell = {\n                    x: cellX,\n                    y: cellY + 1\n                };\n            }\n            // Check for collisions with walls\n            if (adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallHorizontal || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallVertical || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomLeft || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomRight || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopLeft || adjacentCellType === _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopRight) {\n                console.log(\"ghost collided with wall\");\n                willColide = true;\n            }\n            if ((adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.x) === ((_state_pathman_currentCell = state.pathman.currentCell) === null || _state_pathman_currentCell === void 0 ? void 0 : _state_pathman_currentCell.x) && (adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.y) === ((_state_pathman_currentCell1 = state.pathman.currentCell) === null || _state_pathman_currentCell1 === void 0 ? void 0 : _state_pathman_currentCell1.y)) {\n                console.log(\"ghost collided with pathman\");\n                willColide = true;\n                state.phase = \"game-over\";\n            }\n            const otherGhosts = ghosts.filter((g)=>g.id !== ghost.id);\n            otherGhosts.forEach((otherGhost)=>{\n                if ((adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.x) === otherGhost.currentCell.x && (adjacentCell === null || adjacentCell === void 0 ? void 0 : adjacentCell.y) === otherGhost.currentCell.y) {\n                    console.log(\"ghost collided with another ghost\");\n                    willColide = true;\n                }\n            });\n            if (willColide) {\n                ghost.isMoving = false;\n                return;\n            }\n            // Allow wrapping around the maze\n            const { x: mazeWidth, y: mazeHeight } = (0,_maze__WEBPACK_IMPORTED_MODULE_2__.calculateMazeDimensions)();\n            // If going right, should wrap to the same x position on the left side of the maze\n            if (direction === \"right\" && newX + ghostRadius > mazeWidth) {\n                newX = 0 + ghostRadius;\n            }\n            // If going left, should wrap to the same x position on the right side of the maze\n            if (direction === \"left\" && newX - ghostRadius < 0) {\n                newX = mazeWidth - ghostRadius;\n            }\n            // If going up, should wrap to the same y position on the bottom side of the maze\n            if (direction === \"up\" && newY - ghostRadius < 0) {\n                newY = mazeHeight - ghostRadius;\n            }\n            // If going down, should wrap to the same y position on the top side of the maze\n            if (direction === \"down\" && newY + ghostRadius > mazeHeight) {\n                newY = 0 + ghostRadius;\n            }\n            ghost.x = newX;\n            ghost.y = newY;\n            ghost.currentCell = {\n                x: Math.floor(newX / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize),\n                y: Math.floor(newY / _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cellSize)\n            };\n            if (ghost.currentCell.x !== currentCell.x || ghost.currentCell.y !== currentCell.y) {\n                var _state_pathman_currentCell2, _state_pathman_currentCell3;\n                ghost.path = (0,_pathfinding__WEBPACK_IMPORTED_MODULE_5__.aStar)({\n                    x: ghost.currentCell.x,\n                    y: ghost.currentCell.y\n                }, {\n                    x: ((_state_pathman_currentCell2 = state.pathman.currentCell) === null || _state_pathman_currentCell2 === void 0 ? void 0 : _state_pathman_currentCell2.x) || 1,\n                    y: ((_state_pathman_currentCell3 = state.pathman.currentCell) === null || _state_pathman_currentCell3 === void 0 ? void 0 : _state_pathman_currentCell3.y) || 1\n                }, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maze.cells);\n            // console.log(`ghost ${index} reset path`, ghost.path[0])\n            }\n            // Periodically or when Pathman moves, update the ghost's path\n            // if (shouldUpdatePath(ghost)) {\n            // const paths = getTopPaths(ghost, state.pathman, config.maze.cells, 3); // Get top 3 paths\n            // const chosenPath = paths[Math.floor(Math.random() * paths.length)]; // Randomly choose one\n            // ghost.path = chosenPath;\n            // Set the next direction based on the path\n            if (((_ghost_path = ghost.path) === null || _ghost_path === void 0 ? void 0 : _ghost_path.length) > 0) {\n            // const nextStep = ghost.path.shift() // Get the next step in the path\n            // ghost.direction = calculateDirection(ghost, nextStep) // Calculate the new direction based on the next step\n            }\n        });\n    };\n    const updatePellets = ()=>{\n        // Check for collisions\n        const pathmanRadius = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pathman.size / 2;\n        for(let i = 0; i < state.pellets.length; i++){\n            const pellet = state.pellets[i];\n            const distance = Math.sqrt(Math.pow(state.pathman.x - pellet.x, 2) + Math.pow(state.pathman.y - pellet.y, 2));\n            if (distance < pathmanRadius + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pellets.size) {\n                state.pellets.splice(i, 1);\n                i--;\n            }\n        }\n        for(let i = 0; i < state.powerPellets.length; i++){\n            const pellet = state.powerPellets[i];\n            const distance = Math.sqrt(Math.pow(state.pathman.x - pellet.x, 2) + Math.pow(state.pathman.y - pellet.y, 2));\n            if (distance < pathmanRadius + _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].powerPellets.size) {\n                state.powerPellets.splice(i, 1);\n                i--;\n            }\n        }\n    };\n    const updateStats = (deltaTime)=>{\n        state.currentFPS = 1000 / deltaTime;\n    };\n    const handleResize = (event)=>{\n        // Resize the canvas\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        calculateScale();\n        draw();\n    };\n    const handleKeyUp = (event)=>{\n        if (state.phase === \"game-over\" || state.phase === \"game-won\") return;\n        // Toggle pause\n        if (event.key === \" \") {\n            state.phase = state.phase === \"paused\" ? \"playing\" : \"paused\";\n            if (state.phase === \"paused\") {\n                state.overlayText = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].overlayMessages.paused;\n                drawOverlay();\n            } else {\n                state.overlayText = \"\";\n                // If unpausing, re-start the animation loop\n                requestAnimationFrame(animate);\n            }\n        }\n        if (state.phase === \"paused\") return;\n        if (event.key === \"ArrowRight\" || event.key === \"d\") {\n            state.pathman.direction = \"right\";\n            state.pathman.isMoving = true;\n        }\n        if (event.key === \"ArrowLeft\" || event.key === \"a\") {\n            state.pathman.direction = \"left\";\n            state.pathman.isMoving = true;\n        }\n        if (event.key === \"ArrowUp\" || event.key === \"w\") {\n            state.pathman.direction = \"up\";\n            state.pathman.isMoving = true;\n        }\n        if (event.key === \"ArrowDown\" || event.key === \"s\") {\n            state.pathman.direction = \"down\";\n            state.pathman.isMoving = true;\n        }\n    };\n    const handleClick = (event)=>{\n        const clickLocation = {\n            x: event.clientX,\n            y: event.clientY\n        };\n        setTimeout(()=>{\n            state.debug.clickLocation = null;\n        }, 4000);\n        state.debug.clickLocation = clickLocation;\n        const resetButton = {\n            x: canvas.width - 120,\n            y: 86,\n            width: 100,\n            height: 30\n        };\n        if (event.clientX >= resetButton.x && event.clientX <= resetButton.x + resetButton.width && event.clientY >= resetButton.y && event.clientY <= resetButton.y + resetButton.height) {\n            reset();\n        }\n    };\n    const attachEvents = ()=>{\n        window.addEventListener(\"resize\", handleResize);\n        window.addEventListener(\"keyup\", handleKeyUp);\n        window.addEventListener(\"click\", handleClick);\n    };\n    const detachEvents = ()=>{\n        window.removeEventListener(\"resize\", handleResize);\n        window.removeEventListener(\"keyup\", handleKeyUp);\n        window.removeEventListener(\"click\", handleClick);\n    };\n    const animate = (timestamp)=>{\n        // Initialize the previous timestamp\n        if (state.previousAnimationTimestamp === undefined) {\n            state.previousAnimationTimestamp = timestamp;\n            requestAnimationFrame(animate);\n            return;\n        }\n        const deltaTime = timestamp - state.previousAnimationTimestamp;\n        // Update stuff\n        if (state.phase === \"playing\") {\n            updatePathman();\n            updateGhosts();\n            updatePellets();\n            updateStats(deltaTime);\n        }\n        // Draw stuff\n        draw();\n        state.previousAnimationTimestamp = timestamp;\n        if (state.phase === \"paused\") return;\n        requestAnimationFrame(animate);\n    };\n    const run = ()=>{\n        console.log(\"Starting Pathman game...\", canvas);\n        init();\n        attachEvents();\n        draw();\n        // Start the animation loop\n        requestAnimationFrame(animate);\n    };\n    const quit = ()=>{\n        console.log(\"Stopping Pathman game...\");\n        state.previousAnimationTimestamp = undefined;\n        detachEvents();\n    };\n    const reset = ()=>{\n        console.log(\"Resetting Pathman game...\");\n        quit();\n        state = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getInitialState)();\n        run();\n    };\n    return {\n        run,\n        quit,\n        reset\n    };\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (game);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFVBQVU7UUFFOUJ5QixzQkFBc0JDO0lBQ3hCO0lBRUEsTUFBTWUsTUFBTTtRQUNWM0MsUUFBUUMsR0FBRyxDQUFDLDRCQUE0Qm5FO1FBRXhDSTtRQUNBa0c7UUFDQXBHO1FBRUEsMkJBQTJCO1FBQzNCMkYsc0JBQXNCQztJQUN4QjtJQUVBLE1BQU1nQixPQUFPO1FBQ1g1QyxRQUFRQyxHQUFHLENBQUM7UUFFWmxFLE1BQU0wRywwQkFBMEIsR0FBR0M7UUFDbkNKO0lBQ0Y7SUFFQSxNQUFNSCxRQUFRO1FBQ1puQyxRQUFRQyxHQUFHLENBQUM7UUFDWjJDO1FBQ0E3RyxRQUFRTix1REFBZUE7UUFDdkJrSDtJQUNGO0lBRUEsT0FBTztRQUNMQTtRQUNBQztRQUNBVDtJQUNGO0FBQ0Y7QUFFQSwrREFBZXRHLElBQUlBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGF0aG1hbi9nYW1lLnRzP2VlNTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBHYW1lU3RhdGUsIERpcmVjdGlvbiB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IENlbGxUeXBlLCBFbnRpdHksIFBhdGhOb2RlLCBOb2RlIH0gZnJvbSBcIi4vdHlwZXNcIlxuaW1wb3J0IGNvbmZpZyBmcm9tIFwiLi9jb25maWdcIlxuaW1wb3J0IHsgY2FsY3VsYXRlTWF6ZURpbWVuc2lvbnMgfSBmcm9tIFwiLi9tYXplXCJcbmltcG9ydCB7IGdldEluaXRpYWxTdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCJcbmltcG9ydCB1c2VEcmF3IGZyb20gXCIuL2RyYXdcIlxuaW1wb3J0IHsgYVN0YXIgYXMgZmluZFBhdGggfSBmcm9tIFwiLi9wYXRoZmluZGluZ1wiXG5cbmNvbnN0IGdhbWUgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xuICBsZXQgc3RhdGU6IEdhbWVTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpXG4gIGNvbnN0IHsgZHJhdywgZHJhd092ZXJsYXkgfSA9IHVzZURyYXcoY2FudmFzLCBzdGF0ZSlcblxuICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuXG4gICAgY2FsY3VsYXRlU2NhbGUoKVxuICB9XG5cbiAgY29uc3QgY2FsY3VsYXRlU2NhbGUgPSAoKSA9PiB7XG4gICAgLy8gVE9ETzogY2FsY3VsYXRlIHdpZHRoIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgY2VsbHMgaW4gdGhlIG1hemVcbiAgICAvLyBjb25zdCBtYXplV2lkdGggPSAwICsgY29uZmlnLnNpZGViYXJXaWR0aFxuICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHN0YXRlLnNjYWxlID0gc2NhbGVcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVBhdGhtYW4gPSAoKSA9PiB7XG4gICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNlbGwgdGhhdCBwYXRobWFuIGlzIGluIGN1cnJlbnRseVxuICAgIGNvbnN0IGNlbGxYID0gTWF0aC5mbG9vcihzdGF0ZS5wYXRobWFuLnggLyBjb25maWcuY2VsbFNpemUpXG4gICAgY29uc3QgY2VsbFkgPSBNYXRoLmZsb29yKHN0YXRlLnBhdGhtYW4ueSAvIGNvbmZpZy5jZWxsU2l6ZSlcbiAgICBzdGF0ZS5wYXRobWFuLmN1cnJlbnRDZWxsID0geyB4OiBjZWxsWCwgeTogY2VsbFkgfVxuXG4gICAgLy8gQW5pbWF0ZSBtb3V0aFxuICAgIGlmIChzdGF0ZS5wYXRobWFuLmlzTW92aW5nKSB7XG4gICAgICBjb25zdCBtb3V0aFNwZWVkID0gY29uZmlnLnBhdGhtYW4ubW91dGhTcGVlZCAvLyBTcGVlZCBvZiBtb3V0aCBvcGVuaW5nL2Nsb3NpbmdcbiAgICAgIGNvbnN0IG1heExvd2VzdEFuZ2xlID0gY29uZmlnLnBhdGhtYW4ubWF4TG93ZXN0QW5nbGUgLy8gTWF4aW11bSBtb3V0aCBhbmdsZSBpbiByYWRpYW5zXG5cbiAgICAgIGlmIChzdGF0ZS5wYXRobWFuLm1vdXRoT3BlbmluZykge1xuICAgICAgICBzdGF0ZS5wYXRobWFuLm1vdXRoQW5nbGUgLT0gbW91dGhTcGVlZCAvLyBJbmNyZWFzZSB0aGUgbW91dGggYW5nbGVcbiAgICAgICAgaWYgKHN0YXRlLnBhdGhtYW4ubW91dGhBbmdsZSA8IG1heExvd2VzdEFuZ2xlKSB7XG4gICAgICAgICAgc3RhdGUucGF0aG1hbi5tb3V0aEFuZ2xlID0gbWF4TG93ZXN0QW5nbGUgLy8gTGltaXQgdGhlIG1vdXRoIGFuZ2xlXG4gICAgICAgICAgc3RhdGUucGF0aG1hbi5tb3V0aE9wZW5pbmcgPSBmYWxzZSAvLyBTdGFydCBjbG9zaW5nIHRoZSBtb3V0aFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wYXRobWFuLm1vdXRoQW5nbGUgKz0gbW91dGhTcGVlZCAvLyBEZWNyZWFzZSB0aGUgbW91dGggYW5nbGVcbiAgICAgICAgaWYgKHN0YXRlLnBhdGhtYW4ubW91dGhBbmdsZSA+IDApIHtcbiAgICAgICAgICBzdGF0ZS5wYXRobWFuLm1vdXRoQW5nbGUgPSAwXG4gICAgICAgICAgc3RhdGUucGF0aG1hbi5tb3V0aE9wZW5pbmcgPSB0cnVlIC8vIFN0YXJ0IG9wZW5pbmcgdGhlIG1vdXRoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNb3ZlXG4gICAgaWYgKHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uID09PSBcIm5vbmVcIiB8fCAhc3RhdGUucGF0aG1hbi5pc01vdmluZykgcmV0dXJuXG5cbiAgICBsZXQgbmV3WCA9IHN0YXRlLnBhdGhtYW4ueFxuICAgIGxldCBuZXdZID0gc3RhdGUucGF0aG1hbi55XG5cbiAgICBpZiAoc3RhdGUucGF0aG1hbi5kaXJlY3Rpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgbmV3WCArPSBjb25maWcucGF0aG1hbi5zcGVlZFxuICAgIH1cbiAgICBpZiAoc3RhdGUucGF0aG1hbi5kaXJlY3Rpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICBuZXdYIC09IGNvbmZpZy5wYXRobWFuLnNwZWVkXG4gICAgfVxuICAgIGlmIChzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9PT0gXCJ1cFwiKSB7XG4gICAgICBuZXdZIC09IGNvbmZpZy5wYXRobWFuLnNwZWVkXG4gICAgfVxuICAgIGlmIChzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9PT0gXCJkb3duXCIpIHtcbiAgICAgIG5ld1kgKz0gY29uZmlnLnBhdGhtYW4uc3BlZWRcbiAgICB9XG5cbiAgICBjb25zdCBwYXRobWFuUmFkaXVzID0gY29uZmlnLnBhdGhtYW4uc2l6ZSAvIDJcblxuICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zXG4gICAgY29uc3QgbWF6ZSA9IGNvbmZpZy5tYXplLmNlbGxzXG4gICAgY29uc3QgY3VycmVudENlbGwgPSB7IHg6IGNlbGxYLCB5OiBjZWxsWSB9XG4gICAgc3RhdGUuZGVidWcuY3VycmVudFBhdGhtYW5Qb3NpdGlvbiA9IHtcbiAgICAgIHg6IHN0YXRlLnBhdGhtYW4ueCxcbiAgICAgIHk6IHN0YXRlLnBhdGhtYW4ueSxcbiAgICAgIGN1cnJlbnRDZWxsLFxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uXG4gICAgbGV0IGFkamFjZW50Q2VsbFxuXG4gICAgbGV0IHdpbGxDb2xpZGUgPSBmYWxzZVxuXG4gICAgaWYgKFxuICAgICAgZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgJiZcbiAgICAgIHN0YXRlLnBhdGhtYW4ueCA+PVxuICAgICAgICBjZWxsWCAqIGNvbmZpZy5jZWxsU2l6ZSArIGNvbmZpZy5jZWxsU2l6ZSAtIHBhdGhtYW5SYWRpdXNcbiAgICApIHtcbiAgICAgIGFkamFjZW50Q2VsbCA9IG1hemVbY2VsbFldPy5bY2VsbFggKyAxXVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgJiZcbiAgICAgIHN0YXRlLnBhdGhtYW4ueCA8PSBjZWxsWCAqIGNvbmZpZy5jZWxsU2l6ZSArIHBhdGhtYW5SYWRpdXNcbiAgICApIHtcbiAgICAgIGFkamFjZW50Q2VsbCA9IG1hemVbY2VsbFldPy5bY2VsbFggLSAxXVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmXG4gICAgICBzdGF0ZS5wYXRobWFuLnkgPD0gY2VsbFkgKiBjb25maWcuY2VsbFNpemUgKyBwYXRobWFuUmFkaXVzXG4gICAgKSB7XG4gICAgICBhZGphY2VudENlbGwgPSBtYXplW2NlbGxZIC0gMV0/LltjZWxsWF1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBkaXJlY3Rpb24gPT09IFwiZG93blwiICYmXG4gICAgICBzdGF0ZS5wYXRobWFuLnkgPj1cbiAgICAgICAgY2VsbFkgKiBjb25maWcuY2VsbFNpemUgKyBjb25maWcuY2VsbFNpemUgLSBwYXRobWFuUmFkaXVzXG4gICAgKSB7XG4gICAgICBhZGphY2VudENlbGwgPSBtYXplW2NlbGxZICsgMV0/LltjZWxsWF1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB3aXRoIHdhbGxzXG4gICAgaWYgKFxuICAgICAgYWRqYWNlbnRDZWxsID09PSBDZWxsVHlwZS5XYWxsSG9yaXpvbnRhbCB8fFxuICAgICAgYWRqYWNlbnRDZWxsID09PSBDZWxsVHlwZS5XYWxsVmVydGljYWwgfHxcbiAgICAgIGFkamFjZW50Q2VsbCA9PT0gQ2VsbFR5cGUuV2FsbENvcm5lclRvcExlZnQgfHxcbiAgICAgIGFkamFjZW50Q2VsbCA9PT0gQ2VsbFR5cGUuV2FsbENvcm5lclRvcFJpZ2h0IHx8XG4gICAgICBhZGphY2VudENlbGwgPT09IENlbGxUeXBlLldhbGxDb3JuZXJCb3R0b21MZWZ0IHx8XG4gICAgICBhZGphY2VudENlbGwgPT09IENlbGxUeXBlLldhbGxDb3JuZXJCb3R0b21SaWdodFxuICAgICkge1xuICAgICAgd2lsbENvbGlkZSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB3aXRoIGNhbnZhc1xuICAgIC8vIGlmIChuZXdYIC0gcGF0aG1hblJhZGl1cyA8IDAgfHwgbmV3WCArIHBhdGhtYW5SYWRpdXMgPiBjYW52YXMud2lkdGgpIHtcbiAgICAvLyAgIHdpbGxDb2xpZGUgPSB0cnVlXG4gICAgLy8gfVxuXG4gICAgLy8gaWYgKG5ld1kgLSBwYXRobWFuUmFkaXVzIDwgMCB8fCBuZXdZICsgcGF0aG1hblJhZGl1cyA+IGNhbnZhcy5oZWlnaHQpIHtcbiAgICAvLyAgIHdpbGxDb2xpZGUgPSB0cnVlXG4gICAgLy8gfVxuXG4gICAgaWYgKHdpbGxDb2xpZGUpIHtcbiAgICAgIHN0YXRlLnBhdGhtYW4uaXNNb3ZpbmcgPSBmYWxzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQWxsb3cgd3JhcHBpbmcgYXJvdW5kIHRoZSBtYXplXG4gICAgY29uc3QgeyB4OiBtYXplV2lkdGgsIHk6IG1hemVIZWlnaHQgfSA9IGNhbGN1bGF0ZU1hemVEaW1lbnNpb25zKClcblxuICAgIC8vIElmIGdvaW5nIHJpZ2h0LCBzaG91bGQgd3JhcCB0byB0aGUgc2FtZSB4IHBvc2l0aW9uIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIG1hemVcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgJiYgbmV3WCArIHBhdGhtYW5SYWRpdXMgPiBtYXplV2lkdGgpIHtcbiAgICAgIG5ld1ggPSAwICsgcGF0aG1hblJhZGl1c1xuICAgIH1cblxuICAgIC8vIElmIGdvaW5nIGxlZnQsIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHggcG9zaXRpb24gb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG1hemVcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImxlZnRcIiAmJiBuZXdYIC0gcGF0aG1hblJhZGl1cyA8IDApIHtcbiAgICAgIG5ld1ggPSBtYXplV2lkdGggLSBwYXRobWFuUmFkaXVzXG4gICAgfVxuXG4gICAgLy8gSWYgZ29pbmcgdXAsIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHkgcG9zaXRpb24gb24gdGhlIGJvdHRvbSBzaWRlIG9mIHRoZSBtYXplXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmIG5ld1kgLSBwYXRobWFuUmFkaXVzIDwgMCkge1xuICAgICAgbmV3WSA9IG1hemVIZWlnaHQgLSBwYXRobWFuUmFkaXVzXG4gICAgfVxuXG4gICAgLy8gSWYgZ29pbmcgZG93biwgc2hvdWxkIHdyYXAgdG8gdGhlIHNhbWUgeSBwb3NpdGlvbiBvbiB0aGUgdG9wIHNpZGUgb2YgdGhlIG1hemVcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIiAmJiBuZXdZICsgcGF0aG1hblJhZGl1cyA+IG1hemVIZWlnaHQpIHtcbiAgICAgIG5ld1kgPSAwICsgcGF0aG1hblJhZGl1c1xuICAgIH1cblxuICAgIHN0YXRlLnBhdGhtYW4ueCA9IG5ld1hcbiAgICBzdGF0ZS5wYXRobWFuLnkgPSBuZXdZXG4gICAgc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbCA9IHtcbiAgICAgIHg6IE1hdGguZmxvb3IobmV3WCAvIGNvbmZpZy5jZWxsU2l6ZSksXG4gICAgICB5OiBNYXRoLmZsb29yKG5ld1kgLyBjb25maWcuY2VsbFNpemUpLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZUdob3N0cyA9ICgpID0+IHtcbiAgICBjb25zdCBnaG9zdHMgPSBzdGF0ZS5naG9zdHNcblxuICAgIGlmICghc3RhdGUucGF0aG1hbi5jdXJyZW50Q2VsbCkgcmV0dXJuXG5cbiAgICBnaG9zdHMuZm9yRWFjaCgoZ2hvc3QsIGluZGV4KSA9PiB7XG4gICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2VsbCB0aGF0IGdob3N0IGlzIGluIGN1cnJlbnRseVxuICAgICAgY29uc3QgY2VsbFggPSBNYXRoLmZsb29yKGdob3N0LnggLyBjb25maWcuY2VsbFNpemUpXG4gICAgICBjb25zdCBjZWxsWSA9IE1hdGguZmxvb3IoZ2hvc3QueSAvIGNvbmZpZy5jZWxsU2l6ZSlcbiAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0geyB4OiBjZWxsWCwgeTogY2VsbFkgfVxuICAgICAgZ2hvc3QuY3VycmVudENlbGwgPSBjdXJyZW50Q2VsbFxuXG4gICAgICBpZiAoZ2hvc3QucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZ2hvc3QucGF0aCA9IGZpbmRQYXRoKFxuICAgICAgICAgIHsgeDogZ2hvc3QuY3VycmVudENlbGwueCwgeTogZ2hvc3QuY3VycmVudENlbGwueSB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHg6IHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGwhLnggfHwgMSxcbiAgICAgICAgICAgIHk6IHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGwhLnkgfHwgMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmZpZy5tYXplLmNlbGxzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gTW92ZVxuICAgICAgY29uc3QgZ2hvc3RSYWRpdXMgPSBjb25maWcuZ2hvc3RzLnNpemUgLyAyXG4gICAgICBjb25zdCBtYXplID0gY29uZmlnLm1hemUuY2VsbHNcblxuICAgICAgbGV0IG5ld1ggPSBnaG9zdC54XG4gICAgICBsZXQgbmV3WSA9IGdob3N0LnlcblxuICAgICAgLy8gQWR2YW5jZSB0b3dhcmRzIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHBhdGhcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZURpcmVjdGlvbiA9IChcbiAgICAgICAgZW50aXR5OiBFbnRpdHksXG4gICAgICAgIG5leHRTdGVwOiBQYXRoTm9kZVxuICAgICAgKTogRGlyZWN0aW9uID0+IHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNhbWUgY2VsbFxuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV4dFN0ZXAueCA9PT0gZW50aXR5LmN1cnJlbnRDZWxsIS54ICYmXG4gICAgICAgICAgbmV4dFN0ZXAueSA9PT0gZW50aXR5LmN1cnJlbnRDZWxsIS55XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBlbnRpdHkuZGlyZWN0aW9uIVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5leHQgY2VsbCBpbiBhYnNvbHV0ZSBjYW52YXMgY29vcmRpbmF0ZXNcbiAgICAgICAgY29uc3QgbmV4dENlbGxDZW50ZXJYID1cbiAgICAgICAgICBuZXh0U3RlcC54ICogY29uZmlnLmNlbGxTaXplICsgY29uZmlnLmNlbGxTaXplIC8gMlxuICAgICAgICBjb25zdCBuZXh0Q2VsbENlbnRlclkgPVxuICAgICAgICAgIG5leHRTdGVwLnkgKiBjb25maWcuY2VsbFNpemUgKyBjb25maWcuY2VsbFNpemUgLyAyXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGluIGNlbGwgY29vcmRpbmF0ZXMgYmV0d2VlbiB0aGUgZW50aXR5J3MgY3VycmVudCBjZWxsIGFuZCB0aGUgbmV4dCBzdGVwXG4gICAgICAgIGNvbnN0IGNlbGxEZWx0YVggPSBuZXh0U3RlcC54IC0gZW50aXR5LmN1cnJlbnRDZWxsIS54XG4gICAgICAgIGNvbnN0IGNlbGxEZWx0YVkgPSBuZXh0U3RlcC55IC0gZW50aXR5LmN1cnJlbnRDZWxsIS55XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwcmltYXJ5IGF4aXMgb2YgbW92ZW1lbnQgYmFzZWQgb24gdGhlIGxhcmdlciBkZWx0YVxuICAgICAgICBjb25zdCBwcmltYXJ5QXhpcyA9XG4gICAgICAgICAgTWF0aC5hYnMoY2VsbERlbHRhWCkgPiBNYXRoLmFicyhjZWxsRGVsdGFZKSA/IFwieFwiIDogXCJ5XCJcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBkaXJlY3Rpb24gYXMgXCJub25lXCJcbiAgICAgICAgbGV0IGRpcmVjdGlvbjogRGlyZWN0aW9uID0gXCJub25lXCJcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBiYXNlZCBvbiB0aGUgcHJpbWFyeSBheGlzIGFuZCB0aGUgc2lnbiBvZiB0aGUgZGVsdGFcbiAgICAgICAgaWYgKHByaW1hcnlBeGlzID09PSBcInhcIikge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IGNlbGxEZWx0YVggPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXJlY3Rpb24gPSBjZWxsRGVsdGFZID4gMCA/IFwiZG93blwiIDogXCJ1cFwiXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50aXR5LmRpcmVjdGlvbiA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZW50aXR5IGhhcyByZWFjaGVkIHRoZSBjZW50ZXIgb2YgdGhlIG5leHQgY2VsbCBhbG9uZyB0aGUgcHJpbWFyeSBheGlzIG9mIG1vdmVtZW50XG4gICAgICAgIC8vIElmIG5vdCwgY29udGludWUgaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgICAgIGlmIChlbnRpdHkuZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgJiYgZW50aXR5LnggPCBuZXh0Q2VsbENlbnRlclgpXG4gICAgICAgICAgcmV0dXJuIGVudGl0eS5kaXJlY3Rpb24hXG4gICAgICAgIGlmIChlbnRpdHkuZGlyZWN0aW9uID09PSBcImxlZnRcIiAmJiBlbnRpdHkueCA+IG5leHRDZWxsQ2VudGVyWClcbiAgICAgICAgICByZXR1cm4gZW50aXR5LmRpcmVjdGlvbiFcbiAgICAgICAgaWYgKGVudGl0eS5kaXJlY3Rpb24gPT09IFwidXBcIiAmJiBlbnRpdHkueSA+IG5leHRDZWxsQ2VudGVyWSlcbiAgICAgICAgICByZXR1cm4gZW50aXR5LmRpcmVjdGlvbiFcbiAgICAgICAgaWYgKGVudGl0eS5kaXJlY3Rpb24gPT09IFwiZG93blwiICYmIGVudGl0eS55IDwgbmV4dENlbGxDZW50ZXJZKVxuICAgICAgICAgIHJldHVybiBlbnRpdHkuZGlyZWN0aW9uIVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbmV3IGRpcmVjdGlvbiBpZiB0aGUgZW50aXR5IGhhcyByZWFjaGVkIHRoZSBjZW50ZXIgb2YgdGhlIG5leHQgY2VsbFxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGlmIChnaG9zdC5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGdob3N0LnBhdGhbMF0ueCA9PT0gZ2hvc3QuY3VycmVudENlbGwueCAmJlxuICAgICAgICAgIGdob3N0LnBhdGhbMF0ueSA9PT0gZ2hvc3QuY3VycmVudENlbGwueVxuICAgICAgICApIHtcbiAgICAgICAgICBnaG9zdC5wYXRoLnNoaWZ0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRTdGVwOiBQYXRoTm9kZSA9IGdob3N0LnBhdGhbMF0hIC8vIEdldCB0aGUgbmV4dCBzdGVwIGluIHRoZSBwYXRoXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coYGdob3N0ICR7aW5kZXh9IG5leHQgc3RlcGAsIG5leHRTdGVwLngsIG5leHRTdGVwLnksIGdob3N0LmRpcmVjdGlvbilcblxuICAgICAgICBpZiAoIW5leHRTdGVwKSByZXR1cm5cblxuICAgICAgICBnaG9zdC5kaXJlY3Rpb24gPSBjYWxjdWxhdGVEaXJlY3Rpb24oZ2hvc3QsIG5leHRTdGVwKSAvLyBDYWxjdWxhdGUgdGhlIG5ldyBkaXJlY3Rpb24gYmFzZWQgb24gdGhlIG5leHQgc3RlcFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgZ2hvc3QgJHtpbmRleH0gbmV3IGRpcmVjdGlvbmAsIGdob3N0LmRpcmVjdGlvbilcbiAgICAgIH1cblxuICAgICAgLy8gTW92ZVxuICAgICAgaWYgKGdob3N0LmRpcmVjdGlvbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIG5ld1ggKz0gY29uZmlnLmdob3N0cy5zcGVlZFxuICAgICAgfVxuICAgICAgaWYgKGdob3N0LmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgbmV3WCAtPSBjb25maWcuZ2hvc3RzLnNwZWVkXG4gICAgICB9XG4gICAgICBpZiAoZ2hvc3QuZGlyZWN0aW9uID09PSBcInVwXCIpIHtcbiAgICAgICAgbmV3WSAtPSBjb25maWcuZ2hvc3RzLnNwZWVkXG4gICAgICB9XG4gICAgICBpZiAoZ2hvc3QuZGlyZWN0aW9uID09PSBcImRvd25cIikge1xuICAgICAgICBuZXdZICs9IGNvbmZpZy5naG9zdHMuc3BlZWRcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdob3N0LmRpcmVjdGlvblxuICAgICAgbGV0IGFkamFjZW50Q2VsbFR5cGVcbiAgICAgIGxldCBhZGphY2VudENlbGw6IE5vZGUgfCB1bmRlZmluZWRcblxuICAgICAgbGV0IHdpbGxDb2xpZGUgPSBmYWxzZVxuXG4gICAgICBpZiAoXG4gICAgICAgIGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiICYmXG4gICAgICAgIGdob3N0LnggPj0gY2VsbFggKiBjb25maWcuY2VsbFNpemUgKyBjb25maWcuY2VsbFNpemUgLSBnaG9zdFJhZGl1c1xuICAgICAgKSB7XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPSBtYXplW2NlbGxZXT8uW2NlbGxYICsgMV1cbiAgICAgICAgYWRqYWNlbnRDZWxsID0geyB4OiBjZWxsWCArIDEsIHk6IGNlbGxZIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBkaXJlY3Rpb24gPT09IFwibGVmdFwiICYmXG4gICAgICAgIGdob3N0LnggPD0gY2VsbFggKiBjb25maWcuY2VsbFNpemUgKyBnaG9zdFJhZGl1c1xuICAgICAgKSB7XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPSBtYXplW2NlbGxZXT8uW2NlbGxYIC0gMV1cbiAgICAgICAgYWRqYWNlbnRDZWxsID0geyB4OiBjZWxsWCAtIDEsIHk6IGNlbGxZIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBkaXJlY3Rpb24gPT09IFwidXBcIiAmJlxuICAgICAgICBnaG9zdC55IDw9IGNlbGxZICogY29uZmlnLmNlbGxTaXplICsgZ2hvc3RSYWRpdXNcbiAgICAgICkge1xuICAgICAgICBhZGphY2VudENlbGxUeXBlID0gbWF6ZVtjZWxsWSAtIDFdPy5bY2VsbFhdXG4gICAgICAgIGFkamFjZW50Q2VsbCA9IHsgeDogY2VsbFgsIHk6IGNlbGxZIC0gMSB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgZGlyZWN0aW9uID09PSBcImRvd25cIiAmJlxuICAgICAgICBnaG9zdC55ID49IGNlbGxZICogY29uZmlnLmNlbGxTaXplICsgY29uZmlnLmNlbGxTaXplIC0gZ2hvc3RSYWRpdXNcbiAgICAgICkge1xuICAgICAgICBhZGphY2VudENlbGxUeXBlID0gbWF6ZVtjZWxsWSArIDFdPy5bY2VsbFhdXG4gICAgICAgIGFkamFjZW50Q2VsbCA9IHsgeDogY2VsbFgsIHk6IGNlbGxZICsgMSB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zIHdpdGggd2FsbHNcbiAgICAgIGlmIChcbiAgICAgICAgYWRqYWNlbnRDZWxsVHlwZSA9PT0gQ2VsbFR5cGUuV2FsbEhvcml6b250YWwgfHxcbiAgICAgICAgYWRqYWNlbnRDZWxsVHlwZSA9PT0gQ2VsbFR5cGUuV2FsbFZlcnRpY2FsIHx8XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPT09IENlbGxUeXBlLldhbGxDb3JuZXJCb3R0b21MZWZ0IHx8XG4gICAgICAgIGFkamFjZW50Q2VsbFR5cGUgPT09IENlbGxUeXBlLldhbGxDb3JuZXJCb3R0b21SaWdodCB8fFxuICAgICAgICBhZGphY2VudENlbGxUeXBlID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyVG9wTGVmdCB8fFxuICAgICAgICBhZGphY2VudENlbGxUeXBlID09PSBDZWxsVHlwZS5XYWxsQ29ybmVyVG9wUmlnaHRcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLmxvZyhgZ2hvc3QgY29sbGlkZWQgd2l0aCB3YWxsYClcbiAgICAgICAgd2lsbENvbGlkZSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBhZGphY2VudENlbGw/LnggPT09IHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGw/LnggJiZcbiAgICAgICAgYWRqYWNlbnRDZWxsPy55ID09PSBzdGF0ZS5wYXRobWFuLmN1cnJlbnRDZWxsPy55XG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5sb2coYGdob3N0IGNvbGxpZGVkIHdpdGggcGF0aG1hbmApXG4gICAgICAgIHdpbGxDb2xpZGUgPSB0cnVlXG4gICAgICAgIHN0YXRlLnBoYXNlID0gXCJnYW1lLW92ZXJcIlxuICAgICAgfVxuXG4gICAgICBjb25zdCBvdGhlckdob3N0cyA9IGdob3N0cy5maWx0ZXIoKGcpID0+IGcuaWQgIT09IGdob3N0LmlkKVxuICAgICAgb3RoZXJHaG9zdHMuZm9yRWFjaCgob3RoZXJHaG9zdCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYWRqYWNlbnRDZWxsPy54ID09PSBvdGhlckdob3N0LmN1cnJlbnRDZWxsIS54ICYmXG4gICAgICAgICAgYWRqYWNlbnRDZWxsPy55ID09PSBvdGhlckdob3N0LmN1cnJlbnRDZWxsIS55XG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBnaG9zdCBjb2xsaWRlZCB3aXRoIGFub3RoZXIgZ2hvc3RgKVxuICAgICAgICAgIHdpbGxDb2xpZGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmICh3aWxsQ29saWRlKSB7XG4gICAgICAgIGdob3N0LmlzTW92aW5nID0gZmFsc2VcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IHdyYXBwaW5nIGFyb3VuZCB0aGUgbWF6ZVxuICAgICAgY29uc3QgeyB4OiBtYXplV2lkdGgsIHk6IG1hemVIZWlnaHQgfSA9IGNhbGN1bGF0ZU1hemVEaW1lbnNpb25zKClcblxuICAgICAgLy8gSWYgZ29pbmcgcmlnaHQsIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHggcG9zaXRpb24gb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgbWF6ZVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiICYmIG5ld1ggKyBnaG9zdFJhZGl1cyA+IG1hemVXaWR0aCkge1xuICAgICAgICBuZXdYID0gMCArIGdob3N0UmFkaXVzXG4gICAgICB9XG5cbiAgICAgIC8vIElmIGdvaW5nIGxlZnQsIHNob3VsZCB3cmFwIHRvIHRoZSBzYW1lIHggcG9zaXRpb24gb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIG1hemVcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwibGVmdFwiICYmIG5ld1ggLSBnaG9zdFJhZGl1cyA8IDApIHtcbiAgICAgICAgbmV3WCA9IG1hemVXaWR0aCAtIGdob3N0UmFkaXVzXG4gICAgICB9XG5cbiAgICAgIC8vIElmIGdvaW5nIHVwLCBzaG91bGQgd3JhcCB0byB0aGUgc2FtZSB5IHBvc2l0aW9uIG9uIHRoZSBib3R0b20gc2lkZSBvZiB0aGUgbWF6ZVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmIG5ld1kgLSBnaG9zdFJhZGl1cyA8IDApIHtcbiAgICAgICAgbmV3WSA9IG1hemVIZWlnaHQgLSBnaG9zdFJhZGl1c1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBnb2luZyBkb3duLCBzaG91bGQgd3JhcCB0byB0aGUgc2FtZSB5IHBvc2l0aW9uIG9uIHRoZSB0b3Agc2lkZSBvZiB0aGUgbWF6ZVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgJiYgbmV3WSArIGdob3N0UmFkaXVzID4gbWF6ZUhlaWdodCkge1xuICAgICAgICBuZXdZID0gMCArIGdob3N0UmFkaXVzXG4gICAgICB9XG5cbiAgICAgIGdob3N0LnggPSBuZXdYXG4gICAgICBnaG9zdC55ID0gbmV3WVxuICAgICAgZ2hvc3QuY3VycmVudENlbGwgPSB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IobmV3WCAvIGNvbmZpZy5jZWxsU2l6ZSksXG4gICAgICAgIHk6IE1hdGguZmxvb3IobmV3WSAvIGNvbmZpZy5jZWxsU2l6ZSksXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgZ2hvc3QuY3VycmVudENlbGwueCAhPT0gY3VycmVudENlbGwueCB8fFxuICAgICAgICBnaG9zdC5jdXJyZW50Q2VsbC55ICE9PSBjdXJyZW50Q2VsbC55XG4gICAgICApIHtcbiAgICAgICAgZ2hvc3QucGF0aCA9IGZpbmRQYXRoKFxuICAgICAgICAgIHsgeDogZ2hvc3QuY3VycmVudENlbGwueCwgeTogZ2hvc3QuY3VycmVudENlbGwueSB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHg6IHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGw/LnggfHwgMSxcbiAgICAgICAgICAgIHk6IHN0YXRlLnBhdGhtYW4uY3VycmVudENlbGw/LnkgfHwgMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmZpZy5tYXplLmNlbGxzXG4gICAgICAgIClcbiAgICAgICAgLy8gY29uc29sZS5sb2coYGdob3N0ICR7aW5kZXh9IHJlc2V0IHBhdGhgLCBnaG9zdC5wYXRoWzBdKVxuICAgICAgfVxuXG4gICAgICAvLyBQZXJpb2RpY2FsbHkgb3Igd2hlbiBQYXRobWFuIG1vdmVzLCB1cGRhdGUgdGhlIGdob3N0J3MgcGF0aFxuICAgICAgLy8gaWYgKHNob3VsZFVwZGF0ZVBhdGgoZ2hvc3QpKSB7XG4gICAgICAvLyBjb25zdCBwYXRocyA9IGdldFRvcFBhdGhzKGdob3N0LCBzdGF0ZS5wYXRobWFuLCBjb25maWcubWF6ZS5jZWxscywgMyk7IC8vIEdldCB0b3AgMyBwYXRoc1xuICAgICAgLy8gY29uc3QgY2hvc2VuUGF0aCA9IHBhdGhzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhdGhzLmxlbmd0aCldOyAvLyBSYW5kb21seSBjaG9vc2Ugb25lXG4gICAgICAvLyBnaG9zdC5wYXRoID0gY2hvc2VuUGF0aDtcblxuICAgICAgLy8gU2V0IHRoZSBuZXh0IGRpcmVjdGlvbiBiYXNlZCBvbiB0aGUgcGF0aFxuICAgICAgaWYgKGdob3N0LnBhdGg/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gY29uc3QgbmV4dFN0ZXAgPSBnaG9zdC5wYXRoLnNoaWZ0KCkgLy8gR2V0IHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHBhdGhcbiAgICAgICAgLy8gZ2hvc3QuZGlyZWN0aW9uID0gY2FsY3VsYXRlRGlyZWN0aW9uKGdob3N0LCBuZXh0U3RlcCkgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBuZXh0IHN0ZXBcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29uc3QgdXBkYXRlUGVsbGV0cyA9ICgpID0+IHtcbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9uc1xuICAgIGNvbnN0IHBhdGhtYW5SYWRpdXMgPSBjb25maWcucGF0aG1hbi5zaXplIC8gMlxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5wZWxsZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwZWxsZXQgPSBzdGF0ZS5wZWxsZXRzW2ldXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coc3RhdGUucGF0aG1hbi54IC0gcGVsbGV0LngsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhzdGF0ZS5wYXRobWFuLnkgLSBwZWxsZXQueSwgMilcbiAgICAgIClcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgcGF0aG1hblJhZGl1cyArIGNvbmZpZy5wZWxsZXRzLnNpemUpIHtcbiAgICAgICAgc3RhdGUucGVsbGV0cy5zcGxpY2UoaSwgMSlcbiAgICAgICAgaS0tXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5wb3dlclBlbGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBlbGxldCA9IHN0YXRlLnBvd2VyUGVsbGV0c1tpXVxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KHN0YXRlLnBhdGhtYW4ueCAtIHBlbGxldC54LCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coc3RhdGUucGF0aG1hbi55IC0gcGVsbGV0LnksIDIpXG4gICAgICApXG5cbiAgICAgIGlmIChkaXN0YW5jZSA8IHBhdGhtYW5SYWRpdXMgKyBjb25maWcucG93ZXJQZWxsZXRzLnNpemUpIHtcbiAgICAgICAgc3RhdGUucG93ZXJQZWxsZXRzLnNwbGljZShpLCAxKVxuICAgICAgICBpLS1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1cGRhdGVTdGF0cyA9IChkZWx0YVRpbWU6IG51bWJlcikgPT4ge1xuICAgIHN0YXRlLmN1cnJlbnRGUFMgPSAxMDAwIC8gZGVsdGFUaW1lXG4gIH1cblxuICBjb25zdCBoYW5kbGVSZXNpemUgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgLy8gUmVzaXplIHRoZSBjYW52YXNcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcblxuICAgIGNhbGN1bGF0ZVNjYWxlKClcbiAgICBkcmF3KClcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSBcImdhbWUtb3ZlclwiIHx8IHN0YXRlLnBoYXNlID09PSBcImdhbWUtd29uXCIpIHJldHVyblxuXG4gICAgLy8gVG9nZ2xlIHBhdXNlXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIHtcbiAgICAgIHN0YXRlLnBoYXNlID0gc3RhdGUucGhhc2UgPT09IFwicGF1c2VkXCIgPyBcInBsYXlpbmdcIiA6IFwicGF1c2VkXCJcblxuICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSBcInBhdXNlZFwiKSB7XG4gICAgICAgIHN0YXRlLm92ZXJsYXlUZXh0ID0gY29uZmlnLm92ZXJsYXlNZXNzYWdlcy5wYXVzZWRcbiAgICAgICAgZHJhd092ZXJsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUub3ZlcmxheVRleHQgPSBcIlwiXG4gICAgICAgIC8vIElmIHVucGF1c2luZywgcmUtc3RhcnQgdGhlIGFuaW1hdGlvbiBsb29wXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gXCJwYXVzZWRcIikgcmV0dXJuXG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93UmlnaHRcIiB8fCBldmVudC5rZXkgPT09IFwiZFwiKSB7XG4gICAgICBzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9IFwicmlnaHRcIlxuICAgICAgc3RhdGUucGF0aG1hbi5pc01vdmluZyA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93TGVmdFwiIHx8IGV2ZW50LmtleSA9PT0gXCJhXCIpIHtcbiAgICAgIHN0YXRlLnBhdGhtYW4uZGlyZWN0aW9uID0gXCJsZWZ0XCJcbiAgICAgIHN0YXRlLnBhdGhtYW4uaXNNb3ZpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd1VwXCIgfHwgZXZlbnQua2V5ID09PSBcIndcIikge1xuICAgICAgc3RhdGUucGF0aG1hbi5kaXJlY3Rpb24gPSBcInVwXCJcbiAgICAgIHN0YXRlLnBhdGhtYW4uaXNNb3ZpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBldmVudC5rZXkgPT09IFwic1wiKSB7XG4gICAgICBzdGF0ZS5wYXRobWFuLmRpcmVjdGlvbiA9IFwiZG93blwiXG4gICAgICBzdGF0ZS5wYXRobWFuLmlzTW92aW5nID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgY2xpY2tMb2NhdGlvbiA9IHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RhdGUuZGVidWcuY2xpY2tMb2NhdGlvbiA9IG51bGxcbiAgICB9LCA0MDAwKVxuXG4gICAgc3RhdGUuZGVidWcuY2xpY2tMb2NhdGlvbiA9IGNsaWNrTG9jYXRpb25cblxuICAgIGNvbnN0IHJlc2V0QnV0dG9uID0ge1xuICAgICAgeDogY2FudmFzLndpZHRoIC0gMTIwLFxuICAgICAgeTogODYsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiAzMCxcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBldmVudC5jbGllbnRYID49IHJlc2V0QnV0dG9uLnggJiZcbiAgICAgIGV2ZW50LmNsaWVudFggPD0gcmVzZXRCdXR0b24ueCArIHJlc2V0QnV0dG9uLndpZHRoICYmXG4gICAgICBldmVudC5jbGllbnRZID49IHJlc2V0QnV0dG9uLnkgJiZcbiAgICAgIGV2ZW50LmNsaWVudFkgPD0gcmVzZXRCdXR0b24ueSArIHJlc2V0QnV0dG9uLmhlaWdodFxuICAgICkge1xuICAgICAgcmVzZXQoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGF0dGFjaEV2ZW50cyA9ICgpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBoYW5kbGVLZXlVcClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKVxuICB9XG5cbiAgY29uc3QgZGV0YWNoRXZlbnRzID0gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGhhbmRsZUtleVVwKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spXG4gIH1cblxuICBjb25zdCBhbmltYXRlID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHJldmlvdXMgdGltZXN0YW1wXG4gICAgaWYgKHN0YXRlLnByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLnByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wID0gdGltZXN0YW1wXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWVzdGFtcCAtIHN0YXRlLnByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wXG5cbiAgICAvLyBVcGRhdGUgc3R1ZmZcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICB1cGRhdGVQYXRobWFuKClcbiAgICAgIHVwZGF0ZUdob3N0cygpXG4gICAgICB1cGRhdGVQZWxsZXRzKClcbiAgICAgIHVwZGF0ZVN0YXRzKGRlbHRhVGltZSlcbiAgICB9XG5cbiAgICAvLyBEcmF3IHN0dWZmXG4gICAgZHJhdygpXG5cbiAgICBzdGF0ZS5wcmV2aW91c0FuaW1hdGlvblRpbWVzdGFtcCA9IHRpbWVzdGFtcFxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSBcInBhdXNlZFwiKSByZXR1cm5cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICB9XG5cbiAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgUGF0aG1hbiBnYW1lLi4uXCIsIGNhbnZhcylcblxuICAgIGluaXQoKVxuICAgIGF0dGFjaEV2ZW50cygpXG4gICAgZHJhdygpXG5cbiAgICAvLyBTdGFydCB0aGUgYW5pbWF0aW9uIGxvb3BcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgfVxuXG4gIGNvbnN0IHF1aXQgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJTdG9wcGluZyBQYXRobWFuIGdhbWUuLi5cIilcblxuICAgIHN0YXRlLnByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wID0gdW5kZWZpbmVkXG4gICAgZGV0YWNoRXZlbnRzKClcbiAgfVxuXG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiUmVzZXR0aW5nIFBhdGhtYW4gZ2FtZS4uLlwiKVxuICAgIHF1aXQoKVxuICAgIHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKClcbiAgICBydW4oKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBydW4sXG4gICAgcXVpdCxcbiAgICByZXNldCxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBnYW1lXG4iXSwibmFtZXMiOlsiQ2VsbFR5cGUiLCJjb25maWciLCJjYWxjdWxhdGVNYXplRGltZW5zaW9ucyIsImdldEluaXRpYWxTdGF0ZSIsInVzZURyYXciLCJhU3RhciIsImZpbmRQYXRoIiwiZ2FtZSIsImNhbnZhcyIsInN0YXRlIiwiZHJhdyIsImRyYXdPdmVybGF5IiwiaW5pdCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiY2FsY3VsYXRlU2NhbGUiLCJzY2FsZSIsInVwZGF0ZVBhdGhtYW4iLCJjZWxsWCIsIk1hdGgiLCJmbG9vciIsInBhdGhtYW4iLCJ4IiwiY2VsbFNpemUiLCJjZWxsWSIsInkiLCJjdXJyZW50Q2VsbCIsImlzTW92aW5nIiwibW91dGhTcGVlZCIsIm1heExvd2VzdEFuZ2xlIiwibW91dGhPcGVuaW5nIiwibW91dGhBbmdsZSIsImRpcmVjdGlvbiIsIm5ld1giLCJuZXdZIiwic3BlZWQiLCJwYXRobWFuUmFkaXVzIiwic2l6ZSIsIm1hemUiLCJjZWxscyIsImRlYnVnIiwiY3VycmVudFBhdGhtYW5Qb3NpdGlvbiIsImFkamFjZW50Q2VsbCIsIndpbGxDb2xpZGUiLCJXYWxsSG9yaXpvbnRhbCIsIldhbGxWZXJ0aWNhbCIsIldhbGxDb3JuZXJUb3BMZWZ0IiwiV2FsbENvcm5lclRvcFJpZ2h0IiwiV2FsbENvcm5lckJvdHRvbUxlZnQiLCJXYWxsQ29ybmVyQm90dG9tUmlnaHQiLCJtYXplV2lkdGgiLCJtYXplSGVpZ2h0IiwidXBkYXRlR2hvc3RzIiwiZ2hvc3RzIiwiZm9yRWFjaCIsImdob3N0IiwiaW5kZXgiLCJwYXRoIiwibGVuZ3RoIiwiZ2hvc3RSYWRpdXMiLCJjYWxjdWxhdGVEaXJlY3Rpb24iLCJlbnRpdHkiLCJuZXh0U3RlcCIsIm5leHRDZWxsQ2VudGVyWCIsIm5leHRDZWxsQ2VudGVyWSIsImNlbGxEZWx0YVgiLCJjZWxsRGVsdGFZIiwicHJpbWFyeUF4aXMiLCJhYnMiLCJzaGlmdCIsImFkamFjZW50Q2VsbFR5cGUiLCJjb25zb2xlIiwibG9nIiwicGhhc2UiLCJvdGhlckdob3N0cyIsImZpbHRlciIsImciLCJpZCIsIm90aGVyR2hvc3QiLCJ1cGRhdGVQZWxsZXRzIiwiaSIsInBlbGxldHMiLCJwZWxsZXQiLCJkaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJzcGxpY2UiLCJwb3dlclBlbGxldHMiLCJ1cGRhdGVTdGF0cyIsImRlbHRhVGltZSIsImN1cnJlbnRGUFMiLCJoYW5kbGVSZXNpemUiLCJldmVudCIsImhhbmRsZUtleVVwIiwia2V5Iiwib3ZlcmxheVRleHQiLCJvdmVybGF5TWVzc2FnZXMiLCJwYXVzZWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhbmltYXRlIiwiaGFuZGxlQ2xpY2siLCJjbGlja0xvY2F0aW9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJzZXRUaW1lb3V0IiwicmVzZXRCdXR0b24iLCJyZXNldCIsImF0dGFjaEV2ZW50cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidGltZXN0YW1wIiwicHJldmlvdXNBbmltYXRpb25UaW1lc3RhbXAiLCJ1bmRlZmluZWQiLCJydW4iLCJxdWl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pathman/game.ts\n"));

/***/ }),

/***/ "./pathman/index.ts":
/*!**************************!*\
  !*** ./pathman/index.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ \"./pathman/component.tsx\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7O0FBQXVDO0FBRXZDLCtEQUFlQSxrREFBYUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYXRobWFuL2luZGV4LnRzPzc1YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdhbWVDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCJcblxuZXhwb3J0IGRlZmF1bHQgR2FtZUNvbXBvbmVudFxuIl0sIm5hbWVzIjpbIkdhbWVDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pathman/index.ts\n"));

/***/ }),

/***/ "./pathman/maze.ts":
/*!*************************!*\
  !*** ./pathman/maze.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateMazeDimensions: function() { return /* binding */ calculateMazeDimensions; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./pathman/config.ts\");\n\nconst calculateMazeDimensions = ()=>{\n    const maze = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].maze.cells;\n    const x = maze[0].length * _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellSize;\n    const y = maze.length * _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellSize;\n    return {\n        x,\n        y\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL21hemUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkI7QUFFdEIsTUFBTUMsMEJBQTBCO0lBQ3JDLE1BQU1DLE9BQU9GLG9EQUFXLENBQUNHLEtBQUs7SUFFOUIsTUFBTUMsSUFBSUYsSUFBSSxDQUFDLEVBQUUsQ0FBQ0csTUFBTSxHQUFHTCx3REFBZTtJQUMxQyxNQUFNTyxJQUFJTCxLQUFLRyxNQUFNLEdBQUdMLHdEQUFlO0lBRXZDLE9BQU87UUFBRUk7UUFBR0c7SUFBRTtBQUNoQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhdGhtYW4vbWF6ZS50cz9lODFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb25maWcgZnJvbSBcIi4vY29uZmlnXCJcblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZU1hemVEaW1lbnNpb25zID0gKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSA9PiB7XG4gIGNvbnN0IG1hemUgPSBjb25maWcubWF6ZS5jZWxsc1xuXG4gIGNvbnN0IHggPSBtYXplWzBdLmxlbmd0aCAqIGNvbmZpZy5jZWxsU2l6ZVxuICBjb25zdCB5ID0gbWF6ZS5sZW5ndGggKiBjb25maWcuY2VsbFNpemVcblxuICByZXR1cm4geyB4LCB5IH1cbn1cbiJdLCJuYW1lcyI6WyJjb25maWciLCJjYWxjdWxhdGVNYXplRGltZW5zaW9ucyIsIm1hemUiLCJjZWxscyIsIngiLCJsZW5ndGgiLCJjZWxsU2l6ZSIsInkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pathman/maze.ts\n"));

/***/ }),

/***/ "./pathman/mazes.ts":
/*!**************************!*\
  !*** ./pathman/mazes.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultMaze: function() { return /* binding */ defaultMaze; }\n/* harmony export */ });\nconst defaultMaze = {\n    cells: [\n        [\n            5,\n            3,\n            3,\n            3,\n            3,\n            6,\n            5,\n            3,\n            6,\n            5,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            6,\n            5,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            5,\n            3,\n            3,\n            3,\n            3,\n            6\n        ],\n        [\n            4,\n            2,\n            1,\n            1,\n            1,\n            4,\n            4,\n            1,\n            7,\n            8,\n            1,\n            1,\n            4,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            2,\n            7,\n            8,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            5,\n            6,\n            1,\n            4,\n            4,\n            1,\n            5,\n            6,\n            1,\n            5,\n            4,\n            8,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            1,\n            1,\n            1,\n            1,\n            1,\n            5,\n            6,\n            1,\n            5,\n            4,\n            1,\n            4,\n            1,\n            3,\n            6,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            1,\n            4,\n            1,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            2,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            5,\n            3,\n            3,\n            6,\n            5,\n            8,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            1,\n            5,\n            4,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            8,\n            7,\n            1,\n            1,\n            8,\n            1,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            7,\n            3,\n            3,\n            8,\n            7,\n            3,\n            8,\n            1,\n            3,\n            1,\n            3,\n            4,\n            1,\n            4,\n            8,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            7,\n            8,\n            2,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            4,\n            1,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            5,\n            3,\n            3,\n            3,\n            6,\n            1,\n            1,\n            5,\n            3,\n            3,\n            3,\n            6,\n            1,\n            1,\n            5,\n            3,\n            3,\n            3,\n            3,\n            6,\n            1,\n            1,\n            5,\n            6,\n            1,\n            5,\n            6,\n            1,\n            1,\n            5,\n            3,\n            3,\n            3,\n            6,\n            1,\n            5,\n            3,\n            3,\n            8,\n            1,\n            5,\n            4\n        ],\n        [\n            8,\n            1,\n            7,\n            8,\n            1,\n            5,\n            6,\n            1,\n            4,\n            5,\n            3,\n            6,\n            4,\n            1,\n            1,\n            4,\n            5,\n            3,\n            6,\n            4,\n            1,\n            1,\n            7,\n            3,\n            6,\n            5,\n            3,\n            8,\n            1,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            1,\n            4,\n            5,\n            3,\n            3,\n            8,\n            1,\n            4,\n            1,\n            1,\n            1,\n            1,\n            7,\n            7\n        ],\n        [\n            0,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            1,\n            4,\n            7,\n            3,\n            8,\n            4,\n            1,\n            1,\n            4,\n            4,\n            0,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            3,\n            4,\n            4,\n            1,\n            1,\n            4,\n            7,\n            3,\n            3,\n            6,\n            1,\n            4,\n            1,\n            3,\n            3,\n            6,\n            9,\n            0\n        ],\n        [\n            6,\n            1,\n            5,\n            6,\n            1,\n            7,\n            8,\n            1,\n            4,\n            5,\n            3,\n            3,\n            8,\n            1,\n            1,\n            4,\n            4,\n            4,\n            4,\n            4,\n            1,\n            5,\n            6,\n            1,\n            4,\n            4,\n            1,\n            5,\n            6,\n            1,\n            4,\n            4,\n            3,\n            4,\n            4,\n            1,\n            1,\n            7,\n            3,\n            3,\n            6,\n            4,\n            1,\n            4,\n            1,\n            1,\n            1,\n            4,\n            1,\n            5\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            7,\n            8,\n            4,\n            1,\n            7,\n            8,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            1,\n            5,\n            3,\n            3,\n            8,\n            4,\n            1,\n            4,\n            5,\n            6,\n            1,\n            1,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            5,\n            6,\n            1,\n            4,\n            4,\n            1,\n            5,\n            10,\n            6,\n            1,\n            4,\n            7,\n            3,\n            3,\n            8,\n            1,\n            1,\n            1,\n            1,\n            7,\n            8,\n            1,\n            7,\n            8,\n            1,\n            7,\n            8,\n            1,\n            7,\n            8,\n            1,\n            1,\n            7,\n            3,\n            3,\n            3,\n            8,\n            1,\n            7,\n            8,\n            7,\n            3,\n            3,\n            3,\n            3\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            10,\n            4,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            5,\n            6,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            8,\n            6,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            7,\n            8,\n            1,\n            0,\n            10,\n            0,\n            1,\n            1,\n            1,\n            1,\n            5,\n            6,\n            1,\n            4,\n            4,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            1,\n            7,\n            4,\n            1,\n            5,\n            7,\n            1,\n            6,\n            8,\n            1,\n            4,\n            5,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            7,\n            8,\n            1,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            10,\n            4,\n            1,\n            5,\n            6,\n            1,\n            4,\n            4,\n            1,\n            4,\n            4,\n            1,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            1,\n            4,\n            6,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            1,\n            4,\n            7,\n            1,\n            4\n        ],\n        [\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            4,\n            1,\n            1,\n            1,\n            1,\n            4,\n            0,\n            4,\n            1,\n            7,\n            8,\n            1,\n            7,\n            8,\n            1,\n            7,\n            8,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            2,\n            5,\n            8,\n            1,\n            5,\n            6,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            4\n        ],\n        [\n            7,\n            3,\n            3,\n            3,\n            3,\n            8,\n            7,\n            3,\n            3,\n            3,\n            3,\n            8,\n            3,\n            7,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            8,\n            7,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            3,\n            8\n        ]\n    ],\n    name: \"default\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL21hemVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFFTyxNQUFNQSxjQUFvQjtJQUMvQkMsT0FBTztRQUNMO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3ZKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3RKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRTtZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3JKO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQ3ZKO0lBQ0RDLE1BQU07QUFDUixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhdGhtYW4vbWF6ZXMudHM/NmUyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsVHlwZSwgTWF6ZSB9IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRNYXplOiBNYXplID0ge1xuICBjZWxsczogW1xuICAgIFs1LCAzLCAzLCAzLCAzLCA2LCA1LCAzLCA2LCA1LCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCA2LCA1LCAzLCAzLCAzLCAzLCAzLCAzLCAzLCA1LCAzLCAzLCAzLCAzLCA2XSxcbiAgICBbNCwgMiwgMSwgMSwgMSwgNCwgNCwgMSwgNywgOCwgMSwgMSwgNCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMiwgNywgOCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgNCwgMSwgMSwgMSwgMSwgNF0sXG4gICAgWzQsIDEsIDUsIDYsIDEsIDQsIDQsIDEsIDUsIDYsIDEsIDUsIDQsIDgsIDEsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDEsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDEsIDEsIDEsIDEsIDEsIDUsIDYsIDEsIDUsIDQsIDEsIDQsIDEsIDMsIDYsIDEsIDRdLFxuICAgIFs0LCAxLCA0LCA0LCAxLCA0LCA0LCAxLCA0LCA0LCAxLCAxLCA0LCAxLCAxLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAyLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCA1LCAzLCAzLCA2LCA1LCA4LCA0LCAxLCAxLCAxLCAxLCA0LCAxLCA1LCA0LCAxLCA0XSxcbiAgICBbNCwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgOCwgNywgMSwgMSwgOCwgMSwgMSwgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMSwgMywgMywgMywgMywgMywgMywgMywgNywgMywgMywgOCwgNywgMywgOCwgMSwgMywgMSwgMywgNCwgMSwgNCwgOCwgMSwgNF0sXG4gICAgWzQsIDEsIDQsIDQsIDEsIDcsIDgsIDIsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDQsIDEsIDEsIDRdLFxuICAgIFs0LCAxLCA0LCA0LCAxLCAxLCAxLCAxLCA1LCAzLCAzLCAzLCA2LCAxLCAxLCA1LCAzLCAzLCAzLCA2LCAxLCAxLCA1LCAzLCAzLCAzLCAzLCA2LCAxLCAxLCA1LCA2LCAxLCA1LCA2LCAxLCAxLCA1LCAzLCAzLCAzLCA2LCAxLCA1LCAzLCAzLCA4LCAxLCA1LCA0XSxcbiAgICBbOCwgMSwgNywgOCwgMSwgNSwgNiwgMSwgNCwgNSwgMywgNiwgNCwgMSwgMSwgNCwgNSwgMywgNiwgNCwgMSwgMSwgNywgMywgNiwgNSwgMywgOCwgMSwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgMSwgNCwgNSwgMywgMywgOCwgMSwgNCwgMSwgMSwgMSwgMSwgNywgN10sXG4gICAgWzAsIDEsIDEsIDEsIDEsIDQsIDQsIDEsIDQsIDcsIDMsIDgsIDQsIDEsIDEsIDQsIDQsIDAsIDQsIDQsIDEsIDEsIDEsIDEsIDQsIDQsIDEsIDEsIDEsIDEsIDQsIDQsIDMsIDQsIDQsIDEsIDEsIDQsIDcsIDMsIDMsIDYsIDEsIDQsIDEsIDMsIDMsIDYsIDksIDBdLFxuICAgIFs2LCAxLCA1LCA2LCAxLCA3LCA4LCAxLCA0LCA1LCAzLCAzLCA4LCAxLCAxLCA0LCA0LCA0LCA0LCA0LCAxLCA1LCA2LCAxLCA0LCA0LCAxLCA1LCA2LCAxLCA0LCA0LCAzLCA0LCA0LCAxLCAxLCA3LCAzLCAzLCA2LCA0LCAxLCA0LCAxLCAxLCAxLCA0LCAxLCA1XSxcbiAgICBbNCwgMSwgNCwgNCwgMSwgMSwgMSwgMSwgNCwgNCwgMSwgMSwgMSwgMSwgMSwgNCwgNCwgNywgOCwgNCwgMSwgNywgOCwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgMSwgNSwgMywgMywgOCwgNCwgMSwgNCwgNSwgNiwgMSwgMSwgMSwgNF0sXG4gICAgWzQsIDEsIDQsIDQsIDEsIDUsIDYsIDEsIDQsIDQsIDEsIDUsIDEwLCA2LCAxLCA0LCA3LCAzLCAzLCA4LCAxLCAxLCAxLCAxLCA3LCA4LCAxLCA3LCA4LCAxLCA3LCA4LCAxLCA3LCA4LCAxLCAxLCA3LCAzLCAzLCAzLCA4LCAxLCA3LCA4LCA3LCAzLCAzLCAzLCAzXSxcbiAgICBbNCwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgNCwgNCwgMSwgNCwgMTAsNCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgNSwgNiwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgOCwgNiwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgNF0sXG4gICAgWzQsIDEsIDQsIDQsIDEsIDQsIDQsIDEsIDcsIDgsIDEsIDAsIDEwLDAsIDEsIDEsIDEsIDEsIDUsIDYsIDEsIDQsIDQsIDEsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDEsIDcsIDQsIDEsIDUsIDcsIDEsIDYsIDgsIDEsIDQsIDUsIDEsIDRdLFxuICAgIFs0LCAxLCA3LCA4LCAxLCA0LCA0LCAxLCAxLCAxLCAxLCA0LCAxMCw0LCAxLCA1LCA2LCAxLCA0LCA0LCAxLCA0LCA0LCAxLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAxLCA0LCA2LCAxLCAxLCAxLCAxLCA0LCA0LCAxLCA0LCA3LCAxLCA0XSxcbiAgICBbNCwgMSwgMSwgMSwgMSwgNCwgNCwgMSwgMSwgMSwgMSwgNCwgMCw0LCAxLCA3LCA4LCAxLCA3LCA4LCAxLCA3LCA4LCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAyLCA1LCA4LCAxLCA1LCA2LCAxLCAxLCAxLCAxLCAxLCAxLCAxLCA0XSxcbiAgICBbNywgMywgMywgMywgMywgOCwgNywgMywgMywgMywgMywgOCwgMywgNywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgMywgOCwgNywgMywgMywgMywgMywgMywgMywgMywgOF0sXG4gIF0gYXMgQ2VsbFR5cGVbXVtdLFxuICBuYW1lOiBcImRlZmF1bHRcIixcbn1cbiJdLCJuYW1lcyI6WyJkZWZhdWx0TWF6ZSIsImNlbGxzIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pathman/mazes.ts\n"));

/***/ }),

/***/ "./pathman/pathfinding.ts":
/*!********************************!*\
  !*** ./pathman/pathfinding.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aStar: function() { return /* binding */ aStar; }\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./pathman/types.ts\");\n\nconst aStar = function(startPos, targetPos, grid) {\n    let randomize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n    const openSet = [];\n    const closedSet = [];\n    const path = [];\n    const startNode = {\n        x: startPos.x,\n        y: startPos.y,\n        gCost: 0,\n        hCost: 0,\n        fCost: 0\n    };\n    const targetNode = {\n        x: targetPos.x,\n        y: targetPos.y\n    };\n    openSet.push(startNode);\n    while(openSet.length > 0){\n        let currentNode = openSet[0];\n        openSet.forEach((node)=>{\n            if (node.fCost < currentNode.fCost || node.fCost === currentNode.fCost && node.hCost < currentNode.hCost) {\n                currentNode = node;\n            }\n        });\n        openSet.splice(openSet.indexOf(currentNode), 1);\n        closedSet.push(currentNode);\n        // Target found\n        if (currentNode.x === targetNode.x && currentNode.y === targetNode.y) {\n            let temp = currentNode;\n            while(temp !== undefined){\n                path.push({\n                    x: temp.x,\n                    y: temp.y,\n                    fCost: 0,\n                    gCost: 0,\n                    hCost: 0\n                });\n                temp = temp.parent;\n            }\n            return path.reverse();\n        }\n        const neighbors = randomize ? getShuffledNeighbors(currentNode, grid) : getNeighbors(currentNode, grid);\n        for (const neighbor of neighbors){\n            if (closedSet.some((node)=>node.x === neighbor.x && node.y === neighbor.y)) {\n                continue;\n            }\n            const gCost = currentNode.gCost + 1 // Assuming uniform cost for simplicity\n            ;\n            const hCost = Math.abs(neighbor.x - targetNode.x) + Math.abs(neighbor.y - targetNode.y);\n            const fCost = gCost + hCost;\n            if (!openSet.some((node)=>node.x === neighbor.x && node.y === neighbor.y) || gCost < neighbor.gCost) {\n                neighbor.gCost = gCost;\n                neighbor.hCost = hCost;\n                neighbor.fCost = fCost;\n                neighbor.parent = currentNode;\n                if (!openSet.some((node)=>node.x === neighbor.x && node.y === neighbor.y)) {\n                    openSet.push(neighbor);\n                }\n            }\n        }\n    }\n    return [] // No path found\n    ;\n};\nfunction getShuffledNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    // Shuffle the neighbors array\n    for(let i = neighbors.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [neighbors[i], neighbors[j]] = [\n            neighbors[j],\n            neighbors[i]\n        ];\n    }\n    return neighbors;\n}\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const directions = [\n        [\n            0,\n            -1\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            -1,\n            0\n        ]\n    ] // Up, Right, Down, Left\n    ;\n    for (const [dx, dy] of directions){\n        const x = node.x + dx;\n        const y = node.y + dy;\n        if (x >= 0 && x < grid[0].length && y >= 0 && y < grid.length && grid[y][x] !== _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallHorizontal && grid[y][x] !== _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallVertical && grid[y][x] !== _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopLeft && grid[y][x] !== _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerTopRight && grid[y][x] !== _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomLeft && grid[y][x] !== _types__WEBPACK_IMPORTED_MODULE_0__.CellType.WallCornerBottomRight && !neighbors.some((neighbor)=>neighbor.x === x && neighbor.y === y) && !(node.x === x && node.y === y)) {\n            neighbors.push({\n                x,\n                y,\n                fCost: 0,\n                gCost: 0,\n                hCost: 0\n            });\n        }\n    }\n    return neighbors;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxJQUFJLENBQUNPLEVBQUUsQ0FBQ0QsRUFBRSxLQUFLViw0Q0FBUUEsQ0FBQzJDLGlCQUFpQixJQUN6Q3ZDLElBQUksQ0FBQ08sRUFBRSxDQUFDRCxFQUFFLEtBQUtWLDRDQUFRQSxDQUFDNEMsa0JBQWtCLElBQzFDeEMsSUFBSSxDQUFDTyxFQUFFLENBQUNELEVBQUUsS0FBS1YsNENBQVFBLENBQUM2QyxvQkFBb0IsSUFDNUN6QyxJQUFJLENBQUNPLEVBQUUsQ0FBQ0QsRUFBRSxLQUFLViw0Q0FBUUEsQ0FBQzhDLHFCQUFxQixJQUM3QyxDQUFDbkIsVUFBVUksSUFBSSxDQUFDLENBQUNELFdBQWFBLFNBQVNwQixDQUFDLEtBQUtBLEtBQUtvQixTQUFTbkIsQ0FBQyxLQUFLQSxNQUNqRSxDQUFFUyxDQUFBQSxLQUFLVixDQUFDLEtBQUtBLEtBQUtVLEtBQUtULENBQUMsS0FBS0EsQ0FBQUEsR0FDN0I7WUFDQWdCLFVBQVVYLElBQUksQ0FBQztnQkFBRU47Z0JBQUdDO2dCQUFHRyxPQUFPO2dCQUFHRixPQUFPO2dCQUFHQyxPQUFPO1lBQUU7UUFDdEQ7SUFDRjtJQUVBLE9BQU9jO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGF0aG1hbi9wYXRoZmluZGluZy50cz8xMzhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENlbGxUeXBlLCBNYXplLCBQYXRoTm9kZSwgTm9kZSB9IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IGNvbnN0IGFTdGFyID0gKFxuICBzdGFydFBvczogTm9kZSxcbiAgdGFyZ2V0UG9zOiBOb2RlLFxuICBncmlkOiBNYXplW1wiY2VsbHNcIl0sXG4gIHJhbmRvbWl6ZSA9IHRydWVcbikgPT4ge1xuICBjb25zdCBvcGVuU2V0OiBQYXRoTm9kZVtdID0gW11cbiAgY29uc3QgY2xvc2VkU2V0OiBQYXRoTm9kZVtdID0gW11cbiAgY29uc3QgcGF0aDogUGF0aE5vZGVbXSA9IFtdXG4gIGNvbnN0IHN0YXJ0Tm9kZTogUGF0aE5vZGUgPSB7XG4gICAgeDogc3RhcnRQb3MueCxcbiAgICB5OiBzdGFydFBvcy55LFxuICAgIGdDb3N0OiAwLFxuICAgIGhDb3N0OiAwLFxuICAgIGZDb3N0OiAwLFxuICB9XG4gIGNvbnN0IHRhcmdldE5vZGUgPSB7IHg6IHRhcmdldFBvcy54LCB5OiB0YXJnZXRQb3MueSB9XG4gIG9wZW5TZXQucHVzaChzdGFydE5vZGUpXG5cbiAgd2hpbGUgKG9wZW5TZXQubGVuZ3RoID4gMCkge1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG9wZW5TZXRbMF1cbiAgICBvcGVuU2V0LmZvckVhY2goKG5vZGU6IFBhdGhOb2RlKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIG5vZGUuZkNvc3QgPCBjdXJyZW50Tm9kZS5mQ29zdCB8fFxuICAgICAgICAobm9kZS5mQ29zdCA9PT0gY3VycmVudE5vZGUuZkNvc3QgJiYgbm9kZS5oQ29zdCA8IGN1cnJlbnROb2RlLmhDb3N0KVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gbm9kZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBvcGVuU2V0LnNwbGljZShvcGVuU2V0LmluZGV4T2YoY3VycmVudE5vZGUpLCAxKVxuICAgIGNsb3NlZFNldC5wdXNoKGN1cnJlbnROb2RlKVxuXG4gICAgLy8gVGFyZ2V0IGZvdW5kXG4gICAgaWYgKGN1cnJlbnROb2RlLnggPT09IHRhcmdldE5vZGUueCAmJiBjdXJyZW50Tm9kZS55ID09PSB0YXJnZXROb2RlLnkpIHtcbiAgICAgIGxldCB0ZW1wOiBQYXRoTm9kZSB8IHVuZGVmaW5lZCA9IGN1cnJlbnROb2RlXG4gICAgICB3aGlsZSAodGVtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhdGgucHVzaCh7IHg6IHRlbXAueCwgeTogdGVtcC55LCBmQ29zdDogMCwgZ0Nvc3Q6IDAsIGhDb3N0OiAwIH0pXG4gICAgICAgIHRlbXAgPSB0ZW1wLnBhcmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpXG4gICAgfVxuXG4gICAgY29uc3QgbmVpZ2hib3JzID0gcmFuZG9taXplXG4gICAgICA/IGdldFNodWZmbGVkTmVpZ2hib3JzKGN1cnJlbnROb2RlLCBncmlkKVxuICAgICAgOiBnZXROZWlnaGJvcnMoY3VycmVudE5vZGUsIGdyaWQpXG5cbiAgICBmb3IgKGNvbnN0IG5laWdoYm9yIG9mIG5laWdoYm9ycykge1xuICAgICAgaWYgKFxuICAgICAgICBjbG9zZWRTZXQuc29tZSgobm9kZSkgPT4gbm9kZS54ID09PSBuZWlnaGJvci54ICYmIG5vZGUueSA9PT0gbmVpZ2hib3IueSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBnQ29zdCA9IGN1cnJlbnROb2RlLmdDb3N0ICsgMSAvLyBBc3N1bWluZyB1bmlmb3JtIGNvc3QgZm9yIHNpbXBsaWNpdHlcbiAgICAgIGNvbnN0IGhDb3N0ID1cbiAgICAgICAgTWF0aC5hYnMobmVpZ2hib3IueCAtIHRhcmdldE5vZGUueCkgK1xuICAgICAgICBNYXRoLmFicyhuZWlnaGJvci55IC0gdGFyZ2V0Tm9kZS55KVxuICAgICAgY29uc3QgZkNvc3QgPSBnQ29zdCArIGhDb3N0XG5cbiAgICAgIGlmIChcbiAgICAgICAgIW9wZW5TZXQuc29tZShcbiAgICAgICAgICAobm9kZSkgPT4gbm9kZS54ID09PSBuZWlnaGJvci54ICYmIG5vZGUueSA9PT0gbmVpZ2hib3IueVxuICAgICAgICApIHx8XG4gICAgICAgIGdDb3N0IDwgbmVpZ2hib3IuZ0Nvc3RcbiAgICAgICkge1xuICAgICAgICBuZWlnaGJvci5nQ29zdCA9IGdDb3N0XG4gICAgICAgIG5laWdoYm9yLmhDb3N0ID0gaENvc3RcbiAgICAgICAgbmVpZ2hib3IuZkNvc3QgPSBmQ29zdFxuICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBjdXJyZW50Tm9kZVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb3BlblNldC5zb21lKFxuICAgICAgICAgICAgKG5vZGUpID0+IG5vZGUueCA9PT0gbmVpZ2hib3IueCAmJiBub2RlLnkgPT09IG5laWdoYm9yLnlcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIG9wZW5TZXQucHVzaChuZWlnaGJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXSAvLyBObyBwYXRoIGZvdW5kXG59XG5cbmZ1bmN0aW9uIGdldFNodWZmbGVkTmVpZ2hib3JzKG5vZGU6IFBhdGhOb2RlLCBncmlkOiBNYXplW1wiY2VsbHNcIl0pIHtcbiAgY29uc3QgbmVpZ2hib3JzID0gZ2V0TmVpZ2hib3JzKG5vZGUsIGdyaWQpXG4gIC8vIFNodWZmbGUgdGhlIG5laWdoYm9ycyBhcnJheVxuICBmb3IgKGxldCBpID0gbmVpZ2hib3JzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSlcbiAgICA7W25laWdoYm9yc1tpXSwgbmVpZ2hib3JzW2pdXSA9IFtuZWlnaGJvcnNbal0sIG5laWdoYm9yc1tpXV1cbiAgfVxuICByZXR1cm4gbmVpZ2hib3JzXG59XG5cbmZ1bmN0aW9uIGdldE5laWdoYm9ycyhub2RlOiBQYXRoTm9kZSwgZ3JpZDogTWF6ZVtcImNlbGxzXCJdKTogUGF0aE5vZGVbXSB7XG4gIGNvbnN0IG5laWdoYm9yczogUGF0aE5vZGVbXSA9IFtdXG4gIGNvbnN0IGRpcmVjdGlvbnMgPSBbXG4gICAgWzAsIC0xXSxcbiAgICBbMSwgMF0sXG4gICAgWzAsIDFdLFxuICAgIFstMSwgMF0sXG4gIF0gLy8gVXAsIFJpZ2h0LCBEb3duLCBMZWZ0XG5cbiAgZm9yIChjb25zdCBbZHgsIGR5XSBvZiBkaXJlY3Rpb25zKSB7XG4gICAgY29uc3QgeCA9IG5vZGUueCArIGR4XG4gICAgY29uc3QgeSA9IG5vZGUueSArIGR5XG5cbiAgICBpZiAoXG4gICAgICB4ID49IDAgJiZcbiAgICAgIHggPCBncmlkWzBdLmxlbmd0aCAmJlxuICAgICAgeSA+PSAwICYmXG4gICAgICB5IDwgZ3JpZC5sZW5ndGggJiZcbiAgICAgIGdyaWRbeV1beF0gIT09IENlbGxUeXBlLldhbGxIb3Jpem9udGFsICYmXG4gICAgICBncmlkW3ldW3hdICE9PSBDZWxsVHlwZS5XYWxsVmVydGljYWwgJiZcbiAgICAgIGdyaWRbeV1beF0gIT09IENlbGxUeXBlLldhbGxDb3JuZXJUb3BMZWZ0ICYmXG4gICAgICBncmlkW3ldW3hdICE9PSBDZWxsVHlwZS5XYWxsQ29ybmVyVG9wUmlnaHQgJiZcbiAgICAgIGdyaWRbeV1beF0gIT09IENlbGxUeXBlLldhbGxDb3JuZXJCb3R0b21MZWZ0ICYmXG4gICAgICBncmlkW3ldW3hdICE9PSBDZWxsVHlwZS5XYWxsQ29ybmVyQm90dG9tUmlnaHQgJiZcbiAgICAgICFuZWlnaGJvcnMuc29tZSgobmVpZ2hib3IpID0+IG5laWdoYm9yLnggPT09IHggJiYgbmVpZ2hib3IueSA9PT0geSkgJiZcbiAgICAgICEobm9kZS54ID09PSB4ICYmIG5vZGUueSA9PT0geSlcbiAgICApIHtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHsgeCwgeSwgZkNvc3Q6IDAsIGdDb3N0OiAwLCBoQ29zdDogMCB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWlnaGJvcnNcbn1cbiJdLCJuYW1lcyI6WyJDZWxsVHlwZSIsImFTdGFyIiwic3RhcnRQb3MiLCJ0YXJnZXRQb3MiLCJncmlkIiwicmFuZG9taXplIiwib3BlblNldCIsImNsb3NlZFNldCIsInBhdGgiLCJzdGFydE5vZGUiLCJ4IiwieSIsImdDb3N0IiwiaENvc3QiLCJmQ29zdCIsInRhcmdldE5vZGUiLCJwdXNoIiwibGVuZ3RoIiwiY3VycmVudE5vZGUiLCJmb3JFYWNoIiwibm9kZSIsInNwbGljZSIsImluZGV4T2YiLCJ0ZW1wIiwidW5kZWZpbmVkIiwicGFyZW50IiwicmV2ZXJzZSIsIm5laWdoYm9ycyIsImdldFNodWZmbGVkTmVpZ2hib3JzIiwiZ2V0TmVpZ2hib3JzIiwibmVpZ2hib3IiLCJzb21lIiwiTWF0aCIsImFicyIsImkiLCJqIiwiZmxvb3IiLCJyYW5kb20iLCJkaXJlY3Rpb25zIiwiZHgiLCJkeSIsIldhbGxIb3Jpem9udGFsIiwiV2FsbFZlcnRpY2FsIiwiV2FsbENvcm5lclRvcExlZnQiLCJXYWxsQ29ybmVyVG9wUmlnaHQiLCJXYWxsQ29ybmVyQm90dG9tTGVmdCIsIldhbGxDb3JuZXJCb3R0b21SaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pathman/pathfinding.ts\n"));

/***/ }),

/***/ "./pathman/state.ts":
/*!**************************!*\
  !*** ./pathman/state.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInitialState: function() { return /* binding */ getInitialState; }\n/* harmony export */ });\n/* harmony import */ var _entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entities */ \"./pathman/entities.ts\");\n\nconst getInitialState = ()=>{\n    const pellets = (0,_entities__WEBPACK_IMPORTED_MODULE_0__.createPellets)();\n    const powerPellets = (0,_entities__WEBPACK_IMPORTED_MODULE_0__.createPowerPellets)();\n    const ghosts = (0,_entities__WEBPACK_IMPORTED_MODULE_0__.createGhosts)();\n    const pathman = (0,_entities__WEBPACK_IMPORTED_MODULE_0__.createPathman)();\n    return {\n        scale: 1,\n        pathman,\n        previousAnimationTimestamp: undefined,\n        ghosts,\n        pellets,\n        powerPellets,\n        currentFPS: 0,\n        phase: \"playing\",\n        overlayText: \"\",\n        debug: {\n            clickLocation: null,\n            currentPathmanPosition: null\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL3N0YXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBS21CO0FBSVosTUFBTUksa0JBQWtCO0lBQzdCLE1BQU1DLFVBQVVKLHdEQUFhQTtJQUM3QixNQUFNSyxlQUFlSiw2REFBa0JBO0lBQ3ZDLE1BQU1LLFNBQVNQLHVEQUFZQTtJQUMzQixNQUFNUSxVQUFVTCx3REFBYUE7SUFFN0IsT0FBTztRQUNMTSxPQUFPO1FBQ1BEO1FBQ0FFLDRCQUE0QkM7UUFDNUJKO1FBQ0FGO1FBQ0FDO1FBQ0FNLFlBQVk7UUFDWkMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLE9BQU87WUFDTEMsZUFBZTtZQUNmQyx3QkFBd0I7UUFDMUI7SUFDRjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGF0aG1hbi9zdGF0ZS50cz9kYzBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGNyZWF0ZUdob3N0cyxcbiAgY3JlYXRlUGVsbGV0cyxcbiAgY3JlYXRlUG93ZXJQZWxsZXRzLFxuICBjcmVhdGVQYXRobWFuLFxufSBmcm9tIFwiLi9lbnRpdGllc1wiXG5pbXBvcnQgeyBHYW1lU3RhdGUgfSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgY29uZmlnIGZyb20gXCIuL2NvbmZpZ1wiXG5cbmV4cG9ydCBjb25zdCBnZXRJbml0aWFsU3RhdGUgPSAoKTogR2FtZVN0YXRlID0+IHtcbiAgY29uc3QgcGVsbGV0cyA9IGNyZWF0ZVBlbGxldHMoKVxuICBjb25zdCBwb3dlclBlbGxldHMgPSBjcmVhdGVQb3dlclBlbGxldHMoKVxuICBjb25zdCBnaG9zdHMgPSBjcmVhdGVHaG9zdHMoKVxuICBjb25zdCBwYXRobWFuID0gY3JlYXRlUGF0aG1hbigpXG5cbiAgcmV0dXJuIHtcbiAgICBzY2FsZTogMSxcbiAgICBwYXRobWFuLFxuICAgIHByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wOiB1bmRlZmluZWQsXG4gICAgZ2hvc3RzLFxuICAgIHBlbGxldHMsXG4gICAgcG93ZXJQZWxsZXRzLFxuICAgIGN1cnJlbnRGUFM6IDAsXG4gICAgcGhhc2U6IFwicGxheWluZ1wiLFxuICAgIG92ZXJsYXlUZXh0OiBcIlwiLFxuICAgIGRlYnVnOiB7XG4gICAgICBjbGlja0xvY2F0aW9uOiBudWxsLFxuICAgICAgY3VycmVudFBhdGhtYW5Qb3NpdGlvbjogbnVsbCxcbiAgICB9LFxuICB9XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlR2hvc3RzIiwiY3JlYXRlUGVsbGV0cyIsImNyZWF0ZVBvd2VyUGVsbGV0cyIsImNyZWF0ZVBhdGhtYW4iLCJnZXRJbml0aWFsU3RhdGUiLCJwZWxsZXRzIiwicG93ZXJQZWxsZXRzIiwiZ2hvc3RzIiwicGF0aG1hbiIsInNjYWxlIiwicHJldmlvdXNBbmltYXRpb25UaW1lc3RhbXAiLCJ1bmRlZmluZWQiLCJjdXJyZW50RlBTIiwicGhhc2UiLCJvdmVybGF5VGV4dCIsImRlYnVnIiwiY2xpY2tMb2NhdGlvbiIsImN1cnJlbnRQYXRobWFuUG9zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pathman/state.ts\n"));

/***/ }),

/***/ "./pathman/types.ts":
/*!**************************!*\
  !*** ./pathman/types.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellType: function() { return /* binding */ CellType; }\n/* harmony export */ });\nvar CellType;\n(function(CellType) {\n    CellType[CellType[\"Empty\"] = 0] = \"Empty\";\n    CellType[CellType[\"Pellet\"] = 1] = \"Pellet\";\n    CellType[CellType[\"PowerPellet\"] = 2] = \"PowerPellet\";\n    CellType[CellType[\"WallHorizontal\"] = 3] = \"WallHorizontal\";\n    CellType[CellType[\"WallVertical\"] = 4] = \"WallVertical\";\n    CellType[CellType[\"WallCornerTopLeft\"] = 5] = \"WallCornerTopLeft\";\n    CellType[CellType[\"WallCornerTopRight\"] = 6] = \"WallCornerTopRight\";\n    CellType[CellType[\"WallCornerBottomLeft\"] = 7] = \"WallCornerBottomLeft\";\n    CellType[CellType[\"WallCornerBottomRight\"] = 8] = \"WallCornerBottomRight\";\n    CellType[CellType[\"Pathman\"] = 9] = \"Pathman\";\n    CellType[CellType[\"Ghost\"] = 10] = \"Ghost\";\n})(CellType || (CellType = {}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXRobWFuL3R5cGVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O1VBQVlBOzs7Ozs7Ozs7Ozs7R0FBQUEsYUFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGF0aG1hbi90eXBlcy50cz82OGUzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBlbnVtIENlbGxUeXBlIHtcbiAgRW1wdHkgPSAwLFxuICBQZWxsZXQgPSAxLFxuICBQb3dlclBlbGxldCA9IDIsXG4gIFdhbGxIb3Jpem9udGFsID0gMyxcbiAgV2FsbFZlcnRpY2FsID0gNCxcbiAgV2FsbENvcm5lclRvcExlZnQgPSA1LFxuICBXYWxsQ29ybmVyVG9wUmlnaHQgPSA2LFxuICBXYWxsQ29ybmVyQm90dG9tTGVmdCA9IDcsXG4gIFdhbGxDb3JuZXJCb3R0b21SaWdodCA9IDgsXG4gIFBhdGhtYW4gPSA5LFxuICBHaG9zdCA9IDEwLFxufVxuXG5leHBvcnQgdHlwZSBEaXJlY3Rpb24gPSBcInJpZ2h0XCIgfCBcImxlZnRcIiB8IFwidXBcIiB8IFwiZG93blwiIHwgXCJub25lXCJcblxuZXhwb3J0IHR5cGUgTm9kZSA9IHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBDZWxsID0gTm9kZSAmIHtcbiAgdHlwZT86IENlbGxUeXBlXG59XG5cbmV4cG9ydCB0eXBlIE1hemUgPSB7XG4gIGNlbGxzOiBDZWxsVHlwZVtdW11cbiAgbmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEdhbWVDb25maWcgPSB7XG4gIHBhdGhtYW46IHtcbiAgICBzcGVlZDogbnVtYmVyXG4gICAgc3RhcnRYOiBudW1iZXJcbiAgICBzdGFydFk6IG51bWJlclxuICAgIHN0YXJ0RGlyZWN0aW9uOiBEaXJlY3Rpb25cbiAgICBzaXplOiBudW1iZXJcbiAgICBtb3V0aFNwZWVkOiBudW1iZXJcbiAgICBtYXhMb3dlc3RBbmdsZTogbnVtYmVyXG4gIH1cbiAgZ2hvc3RzOiB7XG4gICAgc3BlZWQ6IG51bWJlclxuICAgIHNpemU6IG51bWJlclxuICB9XG4gIGNvbG9yczoge1xuICAgIHByaW1hcnk6IHN0cmluZ1xuICAgIGJhY2tncm91bmQ6IHN0cmluZ1xuICAgIHRleHQ6IHN0cmluZ1xuICAgIHNlY29uZGFyeVRleHQ6IHN0cmluZ1xuICAgIHdhbGw6IHN0cmluZ1xuICB9XG4gIHBlbGxldHM6IHtcbiAgICBzaXplOiBudW1iZXJcbiAgfVxuICBwb3dlclBlbGxldHM6IHtcbiAgICBzaXplOiBudW1iZXJcbiAgfVxuICBjZWxsU2l6ZTogbnVtYmVyXG4gIHNpZGViYXJXaWR0aDogbnVtYmVyXG4gIG92ZXJsYXlNZXNzYWdlczoge1xuICAgIHBhdXNlZDogc3RyaW5nXG4gICAgZ2FtZU92ZXI6IHN0cmluZ1xuICAgIGdhbWVXb246IHN0cmluZ1xuICB9XG4gIG1hemU6IE1hemVcbiAgd2FsbFdpZHRoOiBudW1iZXJcbiAgc2hvd0dyaWQ6IGJvb2xlYW5cbiAgc2hvd1J1bGVyczogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBFbnRpdHkgPSB7XG4gIHg6IG51bWJlciAvLyBjYW52YXMgeC95IHZhbHVlc1xuICB5OiBudW1iZXIgLy8gY2FudmFzIHgveSB2YWx1ZXNcbiAgY3VycmVudENlbGw/OiBDZWxsXG4gIGlkPzogbnVtYmVyIHwgc3RyaW5nXG4gIGRpcmVjdGlvbj86IERpcmVjdGlvblxuICBpc01vdmluZz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUGF0aG1hbkVudGl0eSA9IEVudGl0eSAmIHtcbiAgbW91dGhPcGVuaW5nOiBib29sZWFuXG4gIG1vdXRoQW5nbGU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBHaG9zdEVudGl0eSA9IEVudGl0eSAmIHtcbiAgcGF0aDogUGF0aE5vZGVbXVxufVxuXG5leHBvcnQgdHlwZSBQYXRoTm9kZSA9IE5vZGUgJiB7XG4gIGdDb3N0OiBudW1iZXJcbiAgaENvc3Q6IG51bWJlclxuICBmQ29zdDogbnVtYmVyXG4gIHBhcmVudD86IFBhdGhOb2RlXG59XG5cbmV4cG9ydCB0eXBlIEdhbWVTdGF0ZSA9IHtcbiAgc2NhbGU6IG51bWJlclxuICBwYXRobWFuOiBQYXRobWFuRW50aXR5XG4gIGdob3N0czogR2hvc3RFbnRpdHlbXVxuICBwZWxsZXRzOiBFbnRpdHlbXVxuICBwb3dlclBlbGxldHM6IEVudGl0eVtdXG4gIHByZXZpb3VzQW5pbWF0aW9uVGltZXN0YW1wOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgY3VycmVudEZQUzogbnVtYmVyXG4gIHBoYXNlOiBcInBsYXlpbmdcIiB8IFwiZ2FtZS1vdmVyXCIgfCBcImdhbWUtd29uXCIgfCBcInBhdXNlZFwiXG4gIG92ZXJsYXlUZXh0OiBzdHJpbmdcbiAgZGVidWc6IHtcbiAgICBjbGlja0xvY2F0aW9uOiBFbnRpdHkgfCBudWxsXG4gICAgY3VycmVudFBhdGhtYW5Qb3NpdGlvbjogRW50aXR5IHwgbnVsbFxuICB9XG59XG4iXSwibmFtZXMiOlsiQ2VsbFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pathman/types.ts\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fdavidchapman%2FCode%2Fpathman%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);